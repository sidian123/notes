[TOC]

# 开发

## servlet container与server
如今很多servlet容器经常会内置web服务器（web server），因此很少有人区分java servelt容器和java web服务器了。

## 控制反转和依赖注入
DI is a subset of IoC
* **IoC** means that objects do not create other objects on which they rely to do their work. Instead, they get the objects that they need from an outside service (for example, xml file or single app service). 2 implementations of IoC, I use, are DI and ServiceLocator.
* **DI** - Dependency Injection is concrete term, in which we provide dependencies of the object at run time by using different injection techniques viz. Setter Injection, Constructor Injection or by Interface Injection.

>已发表博文：[控制反转 vs 依赖注入](https://blog.csdn.net/jdbdh/article/details/82800306)

## 类加载器和classpath
每个类加载器都可以定义一个属于自己的classpath路径



## tomcat的默认web应用
tomcat中webapps下的ROOT目录代表的应用为默认应用。估计host下的该目录都为默认应用。

## eclipse开发问题的一些解决方案
要是maven下载的包毁坏，则在maven的repository中删除它，然后在项目中使用maven->update project...

如果编写程序过程中，eclipse出现了[莫名其妙][2]的问题，可以点击project->clean...清除项目尝试一下。如果导入项目后出现了莫名其妙的问题，很有可能是因为项目与电脑环境冲突，比如jdk版本太高，很多jar包不支持，又如数据库的[驱动包][3]不支持现有数据库的包。

如果eclipse中tomcat出了问题，可以将里面的应用删除，clean整个server的，clear jsp生成的servlet。

[2]:https://www.baidu.com/s?wd=%E8%8E%AB%E5%90%8D%E5%85%B6%E5%A6%99&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd
[3]:https://www.baidu.com/s?wd=%E9%A9%B1%E5%8A%A8%E5%8C%85&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd

## eclipse寻找jvm
1. eclipse先从`eclipse/jre`目录下寻找jvm
2. 如果没有，则咨询`eclipse.ini`文件
3. 最后在`PATH`路径下查找

> 如果是idea的话,  它会自带JDK.

## Spring多容器应用
一个容器可以有父容器，比如springMVC中就有两个容器，一个web应用对应一个`ApplicationContext`容器，为父容器，每个`DispatcherServlet`对应一个`WebApplicationContext`容器，为子容器。父容器中定义的`Bean`都可以被子容器访问到，也可被子容器覆盖。在`ApplicationContext`中可以定义和业务逻辑、数据访问有关的`Bean`，而`WebApplicationContext` 中可以定义和控制器与视图解析器有关的`Bean`。

>参考：
>https://stackoverflow.com/questions/43452644/what-is-the-difference-between-spring-parent-context-and-child-context
>https://stackoverflow.com/questions/18578143/about-multiple-containers-in-spring-framework

## HashMap vs. HashTable
区别：
* `HashMap` is non synchronized. It is not-thread safe and can’t be shared between many threads without proper synchronization code whereas `HashTable` is synchronized. It is thread-safe and can be shared with many threads.
* `HashMap` allows one null key and multiple null values whereas `HashTable` doesn’t allow any null key or value.
* `HashMap` is generally preferred over `HashTable` if thread synchronization is not needed

为何HashMap允许键值为null？
>To successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. Since null is not an object, it can’t implement these methods. HashMap is an advanced version and improvement on the Hashtable. HashMap was created later.

## Session技术
Session是一种会话的抽象概念, 在很多协议中都存在, 如PPPoE. 这里讨论的是HTTP的会话.

HTTP是无状态的，为了能够在HTTP协议之上保持住状态，比如用户是否登陆、购物车等等就需要一种方法来把用户的一个个无状态HTTP请求关联起来。 

这种技术就叫Session。

 Session的功能是把一个个分离的HTTP请求关联起来，只要能实现这个功能，基本上都能叫Session的一种实现。 

- 在Cookie里放个JSESSIONID，在服务器中存上状态，用户请求来了，根据JSESSIONID去服务器里查状态，这是Tomcat的实现方法。 
- 把所有状态都存在Cookie里，服务器给个签名防止伪造，每次请求来了，直接从Cookie里提取状态，这是JWT的实现方法。 
- 在Cookie里放个token，状态不存在中间件里，而是存在Redis里，这也是一种Session实现方法。 

 正确的说法是，把Session存储在Web中间件中（比如存储在Tomcat中），这种做法正在被淘汰，因为这种方案对负载均衡不友好，也不利于快速伸缩。

 把Session存在Redis和前端的方案正在慢慢崛起，尤其是现在微服务架构大行其道的情况下。 

只要HTTP还是无状态的，只要保存状态还是刚需，Session就不会消失，变化的只是它的实现方式。 

举个例子，只要人们还要出行，交通工具就不可能消失，只是实现的方法从走路变成了马车，在变成火车、汽车、飞机，未来可能还有火箭啥的。

>转载至:[session正在被淘汰吗？ - 李明阳的回答 - 知乎](https://www.zhihu.com/question/315397046/answer/695069994)
>
>推荐阅读: [彻底理解cookie，session，token](https://zhuanlan.zhihu.com/p/63061864)

## 非阻塞,异步

两者概念其实是有交叉的, 侧重点不同, 使用在不同的语境下.

* 非阻塞: 调用函数, 无论数据是否可用, 函数立刻返回
* 异步: 执行一个操作, 不等待它的完成便去做其他事情, 该操作结束后再来处理它的返回结果.

意思差不多, 不必太过与纠结这些虚的东西, 混淆也没事.

> 非阻塞,异步, 可能会用到多线程, 可能没有, 如JavaScript引擎.

## AWS与IaaS,PaaS,SaaS

*AWS is a* **cloud service provider**. It provides 3 cloud services, broadly called: **IaaS** (Infrastructure-as-a-Service) **PaaS** (Platform-as-a-Service) **SaaS**(Software-as-a-Service)*

## 运行Python简易服务器

- python3简单web服务器：`python3 -m http.server [port]`
- python简单web服务器：`python -m SimpleHTTPServer [port]`

## 编程思想

### 模块,功能

前后端分离, Package按功能,用途分包的目的, 是为了让**关注点**分离. 

如后端分层设计:

* 控制器: 从如何提供前端访问这个关注点来设计URL映射, 不必写太多功能, 交给服务层.
* 服务层: 关注于如何提供服务
* 数据访问层: 关注于如何操纵数据, 一切设计大部分围绕对象展开的.

### 降低业务复杂度

业务复杂时, 通常跳转很多, 可以通过**增加空间记录**的方式降低业务复杂度

### 数据与算法

算法都是对数据操作, 现在的技术日益更新, 但也逃不出数据与算法的范畴.

一般数据都伴随着算法, 封装成一个对象.然, 数据是由外部获取, 并且封装将之与算法封装起来麻烦时, 仅方法组成一个对象, 称之DAO. DAO常用于接口间的数据操作, 如数据库与Java, 前端与后端的API接口

> 在前端中, 数据常作为状态存在, 此时该对象就是组件.

-----

善用数据结构

* 图
  * 状态机
* 树
  * ...
* ...

### 职责单一

[tomcat 与 nginx，apache的区别是什么？ - David的回答 - 知乎](https://www.zhihu.com/question/32212996/answer/87524617)

## 请求处理模型

A web server needs to handle concurrent connections. There are many ways to do this, some of them are:

- A process per connection.
- A process per connection, and have a pool of processes ready to use.
- A thread per connection.
- A thread per connection, and have a pool of threads ready to use.
- **A single process, handle every event (accepted connection, data available to read, can write to client, ...) on a callback.**
- Some combination of the above.
- ...

At the end, the distinction ends up being in 

* how you store each connection state (explicitly in a context structure, implicitly in the stack, implicitly in a continuation, ...) 
* and how you schedule between connections (let the OS scheduler do it, let the OS polling primitives do it, ...).

> 来源于[what is event driven web server](https://stackoverflow.com/questions/3981566/what-is-event-driven-web-server/3982440#3982440)

# Java

## JVM hot swapping

JVM提供了热置换的功能，即在程序已运行在debug模式，在程序运行时置换程序部分代码。但有一定限制，如只能热更新方法体的内容。

> 参考：[JVM hot swapping](<https://stackoverflow.com/questions/13564785/jvm-hot-swapping>)

## 系统属性

- 运行java是的`-D`参数，如`-Dname=luo`

## Module

### 优点

- 由于JAVA API的package越来越大，直接引入包后，打包后的文件会异常的大。而使用Module，只会打包你需要的module，**使发布文件更小**。

  > 具体为啥，暂不知

- 封装：module含多个package，但允许在被其他module使用时只暴露部分package。

- module的启动检测：Java 9后，程序必须被打包成module。当程序启动时，会检查依赖的module，如果丢失则停止运行。Java 9之前，只有当程序使用到该package、class后才报道错误。

### 基础

- 一个module可含有多个package

- module命名：与package命名一样，但java 9后`_`作为了保留字，因此不要使用。

  > 话说包名命令规则啥？
  >
  > 建议module名与根package名一致，除了一个module含多个package的情况外。

- module根目录：一个module会被编译成一个module根目录，不会出现子目录。如，当一个`com.module`模块含有`com.package1`和`com.package2`时，编译后的目录结构为：

  - com.module
    - com
      - package1
      - package2

- module-info.java：用于描述哪个package被导出（**export**），自身需要（**require**）什么module。编译后位于module根目录下。

- 。。。

- 未命名module：为了兼容，未使用的class或jar位于未命令模块中。未命令模块导出所有package，但已命令模块不用读取。未命令模块可以require模块导出的package。

## 网络

### overview

- TCP：提供可靠的、点对点的连接；接收到的数据与发送时的顺序一致

- UDP：非可靠（即数据可能丢失）；数据接收的顺序不被保证，相互独立

  > UDP对IP协议进行了简单的封装，因此速度比较快；TCP为了可靠性，牺牲了一定速度。
  >
  > 所谓可靠，就是丢包就重发

- ip地址确定host，端口确定应用。

- `java.net`

  - TCP相关：`URL`, `URLConnection`, `Socket`, and `ServerSocket` 
  - UDP相关：`DatagramPacket`, `DatagramSocket`, and `MulticastSocket`

### URL

- 定义：指向网络上一个资源的地址。主要由两部分组成，**协议**和**地址**，由`://`分隔。协议定义了获取资源的方式，地址还可细分，如何细分取决于所用协议。但大多数协议的地址包含如下成分：
  - Host Name：主机名字，即域名
  - Filename：主机内指向文件的路径
  - Port Number（可选）：主机内提供服务的应用对应的端口号
  - Reference（可选）：定位资源内某个部分的引用（锚），如http中的`#anchor`
- [URL](<https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/URL.html>)创建
  - 绝对地址：`URL myURL = new URL("http://example.com/");`
  - 相对地址：`URL page1URL = new URL(myURL, "page1.html");`由第一个参数给出基址。
  - URL传入String时，注意转义，但在分成分传参构建URL的构造函数中，会自动转义。
- URL解析：含有解析URL的方法，并不是所有协议都支持这些方法。
- 直接读取：`openStream()`，内部通过`openConnection().getInputStream()`实现。
- `URLConnection`：`openConnection` 返回`URLConnection` ，该类表示一个具体的连接，常用为http协议，然后强制转化类型为[HttpURLConnection](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/HttpURLConnection.html)。
  - 得到`URLConnection` 后，可以设置一些请求参数，然后执行`connect`方法，这时才真正的创建连接。
  - 一些需要连接的操作会隐式连接，不用执行`connect`，如`getInputStream`、`getOutputStream`
  - 默认不允许获得输出流，需打开：`setDoOutput(true);`

## 设计模式

* 构建对象
  * 简单对象: `new Entity()`
  * 稍微复杂: `Entity.getInstance()`
  * 复杂对象: `Entity entity=EntityFactory.builde()`

## 运行命令行

```java
Runtime rt = Runtime.getRuntime();
Process pr = rt.exec("java -jar map.jar time.rel test.txt debug");
```

`Runtime`代表当前进行的运行环境, 如果是桌面环境`getRuntime()`不能获取到`Runtime`.

## 初始化顺序

见[Java order of Initialization and Instantiation](https://stackoverflow.com/questions/23093470/java-order-of-initialization-and-instantiation)

# 数据库

## 隔离级别
* **read_uncommited**：加写锁，直到事务结束释放，解决丢失修改问题。
* **read_commited**:在上一级别基础上加读锁（可能为乐观锁），读完立即释放，解决脏读。
* **repeatable_read**：在read_uncommited基础上加读锁（可能为乐观锁），直到事务结束释放，解决不可重复读问题。
* **serializable**：在上一级别基础上加间隙锁等等等等，因此解决了幻读。
* 
mysql的默认隔离级别：repeatable_read。

>详细参考：[JDBC 8.1小节](https://blog.csdn.net/jdbdh/article/details/86307289#81__114)

## 事务提交
在原始jdbc中，Connection默认自动提交，也就是没执行一句sql语句就当做一个事务提交。在mybatis中，默认不自动提交，在进行插入、修改等操作后需要手动提交。[并不是事务中提交后才执行sql语句][1]，而是每条都执行，只是callback利用日记可以回滚到初始状态罢了。

----
2019/2/13更新
一般Connection默认自动提交，但是涉及事务处理的Connection会被配置成非自动提交。

[1]:https://stackoverflow.com/questions/26581850/mybatis-committing-a-statement-even-when-autocommit-is-false

## （内、外）连接
* **内连接**（inner join或join）：两表只有成功匹配的记录会被显示出来
* **左外连接**（left join或left outer join）：查询结果集包含左表所有行，和右表匹配的记录，如果无匹配则全null。
* **右外连接**：与左外连接类似。
* **全连接**：不支持，但是可以通过左外连接和右外连接的并集获得。

除了使用连接，还可以在使用如下方式进行多表连接：
```sql
select A.*,B.*
from A,B
where A.id=B.aId
```
## 索引

* 普通索引: 最基本的索引类型, 没有唯一性之类的限制
* 唯一性索引: 与普通索引基本相同, 除了索引列的值必须唯一.
* 主键: 是一种唯一性索引, 但每个表只能存在一个主键.

> 参考: [UNIQUE等于普通索引吗？](https://zhidao.baidu.com/question/555482123.html)

# 系统

## cpu架构
cpu有很多架构，这三种很常见：**ARM** 、**x86**(IA-32、i386)、 **x86_64**(x64、AMD64、intel64)

架构是一个很抽象的概念，不同cpu产商可以生产同一架构的cpu。操作系统通常有对应不同cpu架构的版本。

x86包括i386、i686等处理器，支持32位地址空间。x64支持64位地址空间。

arm采用精简集指令，x86_64和x86采用复杂集指令。

树莓派是arm架构的。arm架构有很多版本，ARMv3道ARMv7支持32位地址空间，ARMv8-A架构支持64位。

>参考：
>https://en.wikipedia.org/wiki/ARM_architecture https://en.wikipedia.org/wiki/X86 https://en.wikipedia.org/wiki/X86_64
>https://serverfault.com/questions/610308/x86-i386-i686-amd64-i5-i7-archtecture-processor-confusion
>https://stackoverflow.com/questions/14794460/how-does-the-arm-architecture-differ-from-x86
>https://askubuntu.com/questions/54296/difference-between-the-i386-download-and-the-amd64

## 开机引导过程
上电，主板自动读取主板上固件（rom）中的**BIOS**或**UEFI**（一段小程序），该程序执行开机自检，可以访问硬盘和主存。
>UEFI更智能, 相当于一个小操作系统

自检后查找磁盘的**第一个扇区**是否存在**引导程序**并加载。BIOS中一个磁盘最多存在一个**启动项**; 而在UEFI中, 会去磁盘中寻找**ESP**分区, 里面可能存在多个`.efi`格式的引导程序, 因此此时一个磁盘可以存在多个**启动项**.
>磁盘有MBR和GPT两种分区方式, BIOS或UEFI需支持(理解)该分区格式才能读取引导程序. BIOS能理解MBR分区格式, UEFI能理解GPT分区格式和MBR(为了兼容BOIS).

一个扇区通常不能装下整个引导程序，仅引导程序的坐标, 指出真正引导程序的位置并加载。注意，加载真正的引导程序后，此时引导程序可以做很多事情了。可以直接加载系统内核，也可以加载其他分区的引导程序来启动其他系统，因此引导程序可能会给出多个**引导项**供你选择。
>如果装了双系统(win+linux)的话, 你通常会看到引导程序grub2提供的多个引导项, 可以选择启动linux, 也可以启动windows.

引导程序加载了内核后, 交由内核运行用户空间的软件（分为系统软件和用户软件），比如加载到多用户图形化的环境供用户使用 (系统软件) , 然后用户运行自己的程序 (用户软件) .

>参考：https://en.wikipedia.org/wiki/Booting

## intel cpu
intel的酷睿i3、i5、i7的差异主要体现在核心数、是否有Turbo Boost技术、缓存大小、超线程上。一般i7比i5好，i5比i3好。但是不是必定成立，因为每个系列都有不同年代的产品，比如i5 4200H 不一定比i3 8100好。最主要的还是要看上面的参数，当然主频也是非常非常重要的参数。

>参考：https://www.pcworld.idg.com.au/article/386100/what_difference_between_an_intel_core_i3_i5_i7_/

## Desktop Environment
![在这里插入图片描述](.零碎知识/20190213161647317.png)
>参考：https://en.wikipedia.org/wiki/Desktop_environment

## linux中文件后缀名
linux中文件后缀名不是必要的，仅仅只是用来描述文件如何被“执行”。下面是一些linux后缀名和它的意义：
| Linux extension              | Windows Equivalent | Short description                                            |
| :--------------------------- | :----------------- | :----------------------------------------------------------- |
| .so, .o                      | .dll               | Object that can be loaded at runtime (Similar to DLL)        |
| .a                           | .lib               | Static library                                               |
| [none], .elf(rare).bin(rare) | .exe, .com(rare)   | Linux executables                                            |
| .sh                          | .bat               | Shell script                                                 |
| .exe                         | .exe               | Mono application, Wine application                           |
| .deb                         | .msi               | Installer package for Debian/Ubuntu releases (Though .deb is much more powerful with native support for dependencies and repos). Note that .deb is actually a .ar archive with a special control file, a special file order, and a different extension. |
| .rpm                         | .msi               | Installer package for RedHat/CentOS releases.                |
| .tar.gz, .tar, .gz           | .zip               | Compressed files that can contain a program or any other data, like images, documents, etc |
| .ko                          | .sys               | Drivers and kernel modules are loaded into the Linux kernel and have more hardware access than other programs. |
| .sh, .php, .py, etc          | .bat               | Linux is capable of running any file that it has an interpreter for. A line at the top of the file called the shebang specifies what interpreter to run the file with. Windows only really runs .bat files in this way. |

>参考：https://www.quora.com/What-is-the-extension-of-a-executable-file-in-Ubuntu

## vps和vm的区别
VPS（Virtual Private Server，虚拟专用服务器），是通过硬件虚拟化技术，在物理服务器之上模拟出来的虚拟服务器。类似于通过VMware或VirtualBox在电脑上运行一个独立的操作系统。每个VPS有独立的内存、硬盘和操作系统。您可以像使用独立服务器一样使用VPS，依据自己的需要配置软件环境。

虚拟主机实质上则是一种软件服务，只能支持特定种类的程序如PHP编写的程序。

要运行一些虚拟主机不支持的程序，如Java程序、可执行程序、NodeJS脚本等，您需要考虑VPS。如果网站访问量非常多，虚拟主机提供的资源不足，您需要考虑VPS。选择合理的VPS套餐非常重要，VPS并不总是比虚拟主机更好。由于VPS需要运行独立的操作系统，两者的资源消耗因素并不完全相同，网站在低配置VPS上的表现可能逊于在虚拟主机上的表现。

虚拟主机使用的一般是共享ip，而vpn有独立ip。

>参考：
>https://www.sugarhosts.com/zh-cn/vps/ssd-vps-hosting
>https://host.zzidc.com/xnkj/1570.html

## 门外汉之PowerShell
win10中有两种shell：powershell和cmd，对于我这种门外汉来说，都很是陌生。但总之，cmd功能有限，我也只会部分命令；**而powershell竟然有很多命令与linux bash命令相似**，对于我这linux初学者来说，用着也很是爽。。这里暂时记记常用的，会在使用中逐步更新：
* `ls`：显示目录或文件
* `pwd`：显示当前目录
* `explorer .`：于当前目录打开文件浏览器
* `cd`：改变工作目录
* `cd ~`：回到用户目录
* `man`、`help`命令或`-h`、`--help`、`/?`选项：查看命令帮助文件。（其实没啥子用）
* `cat`：输出文件内容
* `notepad filename`:用记事本打开文本
* 支持重定向，可用于ssh中传输文件，暂不熟
* `clear`：清空屏幕
* `echo $Env:PATH`：打印PATH变量内容。（与cmd不同，cmd中通过`%PATH%`可以获取值）
* `ls env`：打印全部环境变量
* 获取环境变量: `%NAME%`
* ...

上面的命令基本够本小白使用了，毕竟有GUI的存在，不用会太多命令。
>其余命令可参考：
>[Table of Basic PowerShell Commands](https://blogs.technet.microsoft.com/heyscriptingguy/2015/06/11/table-of-basic-powershell-commands/)

## Linux 线程、进程、进程组和会话
一个会话可以含有多个进程组，一个进程组可以含有多个进程，一个进程可以含有多个线程。每种对象都有自己的ID，如线程号，进程号，进程组号和会话号。

一个进程一般只含有一个线程，且进程号和线程号一致。

每个进程都属于一个唯一的进程组。当进程被创建时，它会称为父进程的进程组的成员。进程组的ID等于进程组的第一个成员，该进程也叫**进程组leader**。

进程组分为：前台进程组、后台进程组和孤儿进程组（Orphaned process groups）。。一个会话最多只有一个前台进程组。不属于前台的进程组就是后台进程组。后台进程组不能从终端（terminal）读，否则会得到停止信号。孤儿进程组可以属于前台或后台进程组，如果进程组leader，提前结束，那么该进程组就是孤儿进程组。进程组leader结束后，所有进程会被发送结束信号，接着发继续信号，即进程捕获或忽视结束信号，会收到继续运行信号。**会话leader**的进程组总是孤儿进程组。

会话进程组中最多只能有一个前台进程组，会话进程组是孤儿进程组。会话进程组的iD为会话leader的ID。每个会话都会有一个**控制终端**（controlling tty），每个进程被创建时会继承父进程的控制终端，因此会话中所有进程都有属性指向该控制终端。在会话被创建时，系统会赋于它控制终端。进程中的三种标准流一般都连接到控制终端的。当会话leader结束后，结束信号会发往所有前台进程组的进程。后台呢？不知道。因此，进程想要成为守护进程，一致常驻内存，需要解除进程与控制终端的绑定。

--------------------
其实我理解的不够，上面的解释我自己都是懵懵的，**很有可能有错误**。但结合实践来说，我想说明的是这几点：
* jobs应该是对应着这里的进程组，在shell上可以执行一个jobs，也就是进程组，比如通过重定向连接多个程序形成进程组。单个进程也算进程组吧。
* 每个ssh连接就是一个会话，关闭ssh，在ssh上运行的程序基本会停止。
* 想要常驻内存，称为守护进程，需要解除控制终端。
* 每个会话都会连接一个控制终端，但控制终端对应的具体设备文件名或许不知道，但是`/dev/tty`永远指着当前会话的控制终端，对它操作就是了。`/dev/tty`是指向当前会话的终端，即使你开多个会话，两个会话的当前控制终端也是不同的，即tty是动态生成数据的。

>参考：https://www.win.tue.nl/~aeb/linux/lk/lk-10.html
>https://www.gnu.org/software/libc/manual/html_node/Controlling-Terminal.html
>https://unix.stackexchange.com/questions/404555/what-is-the-purpose-of-the-controlling-terminal

## MBR与GPT
![](.零碎知识/201903081539021-1562033610771.png)

前446个字节用于存放开机引导程序，后面是四个分区表的空间。

------
![](.零碎知识/20190308153927487.png)
与MBR类似，LBA0前446字节用于存放开机引导程序，原本的分区表内存放特殊标志，标志为GPT分区格式。另外磁盘末还备份了分区信息。

>参考：
>[Master boot record](https://en.wikipedia.org/wiki/Master_boot_record)
>[GUID Partition Table](https://en.wikipedia.org/wiki/GUID_Partition_Table)

## CPU部分知识
cpu中有一对寄存器，一个指向进程的PCB，一个指向含有操作系统指令的表。因此中断到来时，cpu可以找到内核，然后让内核知道当前进程，方便操作系统进行进程管理。

cpu中也有寄存器指向页表，而进程使用的是虚拟地址，当进程访问一个虚拟地址时，由cpu找到页表然后转化为实际物理地址。但是页表需要由操作系统维护，上下文切换时也要维护页表，指向不同进程的页表。

>参考
>http://faculty.salina.k-state.edu/tim/ossg/Introduction/OSworking.html#cpu-response-to-interrupts
>how linux works,Brian Ward,1.3.2 Memory Management

## 进程线程上下文切换

细节太多, 这里直接给出总结:

1. Kernel schedules and executes only threads, not processes. Due to this context swicth happens between threads.
2. Procedure of Context switch between treads belonging to different processes is essentially the same as between threads which belongs to the same process. There is only one additional step in the first case - loading of new virtual address space (which leads to the TLB flush).
3. Context of threads are stored either in the kernel part of the stack of thread or in the thread TCB (not in PCB!).
4. Threads switch introduces performance penalty. There is significant direct cost of threads switch. And even much bigger inderect cost created by cache pollution and TLB flush (if virtual address space was reloaded during switch).

详细见[Steps in Context Switching](https://stackoverflow.com/a/40285741)

## 电脑硬件部分知识
* 一个超线程的核相当于两个核，但是性能肯定比不上两个核。
* 主频=外频*倍频
* FSB前端总线不等于外频
* intel cpu系列：i3、i5、i7、E5。其中，型号后有k的表示可以超频
* 主频：正常工作频率
* 睿频：根据工作情况可自动上涨的频率
* 超频：人为提升的频率，对cpu伤害大，很多cpu不支持超频

>参考：https://www.zhihu.com/question/31362682

## linux中运行windows软件
文中给出了三种方法：
1. **Wine**     
    Wine is a way to run Windows software on Linux, but with no Windows required. Wine is an open-source “**Windows compatibility layer**” that can run Windows programs directly on your Linux desktop. ... Once it's installed, you can then download .exe files for Windows applications and double-click them to run them with Wine.兼容性和性能可能不太好。
    
    > 还有很多运行exe的工具都是基于Wine的, 如crossover, PlayOnLinux等.
    
2. **虚拟机**：如 VirtualBox, VMware, or Linux’s built-in KVM。甚至还提供将一个应用默认模拟成linux应用的功能。性能开销比较大，适合运行office、photoshop之类的软件。

3. **双系统**：运行大型游戏的最终解决方案。

>参考：https://www.pcworld.com/article/2900497/how-to-run-windows-software-in-linux-everything-you-need-to-know.html



## 显卡之大黄蜂
>见博客[显卡之大黄蜂](https://blog.csdn.net/jdbdh/article/details/93161637)

随着笔记本的使用逐渐增多, 消费者开始尝试权衡续航和性能之间的问题. 一般笔记本都是双显卡, 即核显和独显. Intel CPU的集成显卡能很好的续航, 但不能实现独立显卡的很好的性能. NVIDIA公司于是开发了switchable graphics技术, 允许用户选择使用哪种显卡(适配器), 但只有1%的用户才会切换显卡. NVIDIA又开发了Optimus技术, 允许自动切换显卡的使用, 权衡了续航和性能之间的问题.

> 打开windows任务管理器, 你会看到笔记本一般情况下使用核显, 但你玩游戏时会使用独显, 这就是Optimus技术的体现.

但是Optimus技术只适用于window7及以上版本. 为了在Linux下支持Optimus技术, 出现了[大黄蜂方案](<https://github.com/Bumblebee-Project/Bumblebee/wiki>), 一个模拟Optimus技术的方案.

> 即NVIDIA不给一个linux版的Optimus技术实现, 开源社区自己写一个!

据[ArchWiki](https://wiki.archlinux.org/index.php/Bumblebee_(简体中文))介绍, 在大黄蜂方案中, 独立显卡是按需渲染的, 并传输给核显显示, 不需要时则关闭独显, 由核显渲染与显示. 当笔记本通过电池供电时, 则自动关闭独显, 以提供续航.

> 当然, 这样性能还是比直接只使用独显要低点, 毕竟增加了一层逻辑.

据[deepin wiki](https://wiki.deepin.org/index.php?title=%E6%98%BE%E5%8D%A1&language=en#Intel_.26_NVIDIA)介绍, 可以通过以下命名强制使用独显运行程序
```bash
optirun command #使用独显运行command程序
```

> 参考
>
> * [The Bumblebee Project Wiki](<https://github.com/Bumblebee-Project/Bumblebee/wiki>)
> * [History of the project](<https://github.com/Bumblebee-Project/Bumblebee/wiki/History-of-the-project>)
> * [Bumblebee (简体中文) archwiki]([https://wiki.archlinux.org/index.php/Bumblebee_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)](https://wiki.archlinux.org/index.php/Bumblebee_(简体中文)))
> * [deepin wiki](https://wiki.deepin.org/index.php?title=%E6%98%BE%E5%8D%A1&language=en#Intel_.26_NVIDIA)

## 待机,休眠,睡眠

* **睡眠模式Sleep Mode**: 数据存在内存中, 其他设备断电. 唤醒速度快, 但数据易失.

* **休眠模式Hibernate Mode**: 数据存入磁盘, 可完全断电, 但唤醒速度慢

* **混合睡眠模式Hybrid Sleep**: 数据同时存放在内存和磁盘中, 并给内存供电, 其他设备断电. 权衡方案, 唤醒快, 数据安全.

  > * 一般Windows只提供睡眠和休眠模式.
  >
  > * 混合睡眠模式开启后会替代睡眠模式, 即此时睡眠状态就是混合模式
  > * 混合睡眠模式, 在台式机中默认开启, 在笔记本电脑中默认关闭.

> 参考: [whats-the-difference-between-sleep-and-hibernate-in-windows](https://www.howtogeek.com/102897/whats-the-difference-between-sleep-and-hibernate-in-windows/)

# 网路
## URL、URN和URI
URL和URN是URI的一种，URN通常指向一个资源但没有给出他的具体位置和访问方式，而URL通常给出了资源的访问机制和网络地址。

A URN may be compared to a person's name, while a URL may be compared to their street address. In other words, a URN identifies an item and a URL provides a method for finding it.

关于这些名词，经常被混用和用错，所以在看到这些名词时需要从上下文辨析他的具体含义。

>参考：https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#URLs_and_URNs

## url解析
浏览器中看似有中文，其实是浏览器正确解析的结果，如果解析不了，会使用%来表示。

>可参考：[url编码](https://blog.csdn.net/jdbdh/article/details/83932406#42url_471)

## 共享IP和独立IP的区别
连接到互联网的每台计算机都分配了一个唯一的IP地址,以用来相互通信。IP地址是一个32位数字地址，通常是由4个数值从0到255的数字组成，中间有分隔点，例如192.168.0.123。尽管IP地址有数十亿之多，但这一数目仍然是有限的。

在虚拟主机行业有两种类型的IP地址：
* **独立IP地址**是指一个网站拥有自己单独的IP地址。拥有独立IP的网站，无论您输入其网址或其IP地址，都可以访问该网站。
* **共享IP地址**是指多个网站共享同一IP地址。服务器可以根据用户输入的网址来判断用户所请求的网站。在此情况下，直接输入IP地址将进入一个通用页面，而不是您所请求的网站。

由于域名注册量的迅速增长和IP地址的有限性，主机提供商不得不尽量使用共享IP。事实上，数以百计的网站往往共用相同的IP地址。静态IP主机已不再是业界规范，而且通常花费更多。

>参考：https://www.sugarhosts.com/zh-cn/hosting/dedicated-ip

## FTTH、FTTB
光纤入户（**FTTH**）用户需要光纤连接光猫设备才可以使用。

>[光纤宽带][4]是在运营商机房通过设备把电信号调制成光信号，通过[光纤传输][5]到用户处。用户要通过[光纤上网][6]，需要使用运营商机房端设备相配套的光猫设备，把光信号转换为用户电脑等设备可以使用的电信号，通过网线连接用户设备上网使用。光纤两端光口光波长等参数要和运营商机房端设备对应起来才可以使用。因此，光猫设备应该选择运营商提供的。


小区宽带或楼宇宽带，光纤到小区或到楼宇（FTTB）。光纤连接PON设备，通过PON设备分出网线接到用户家。这种情况，用户家不需要光猫，电脑直接接到网线，通过拨号上网即可上网。

>参考：
>https://zhidao.baidu.com/question/511373417.html

[4]:https://www.baidu.com/s?wd=%E5%85%89%E7%BA%A4%E5%AE%BD%E5%B8%A6&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao
[5]:https://www.baidu.com/s?wd=%E5%85%89%E7%BA%A4%E4%BC%A0%E8%BE%93&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao
[6]:https://www.baidu.com/s?wd=%E5%85%89%E7%BA%A4%E4%B8%8A%E7%BD%91&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao

## ipv4私有地址
* **A**类地址`10.0.0.0-10.255.255.255`
* **B**类地址`172.16.0.0—172.31.255.255`
* **C**类地址`192.168.0.0-192.168.255.255`

私有地址也是保留地址，还有其他保留地址，用以特殊用途。比如电信给我的宽带地址就不是公网地址，而是保留地址。。

>保留地址：https://en.wikipedia.org/wiki/Reserved_IP_addresses

## md5、SHA-1
md5(**message-digest algorithm**)信息**摘要算法**，是一个计算出128位哈希值的函数。作为加密哈希函数，一个最基本的要求是，两个不同的信息，不可能计算出相同的哈希值。然后md5没有达到要求，但md5仍然被广泛用于验证数据的完整性，除非数据被故意修改（哈希值仍不变）。linux中可以使用命令`md5sum`得到数据的md5值。

>SHA-1也是类似的**加密算法**，用于验证数据完整性。

>参考：https://en.wikipedia.org/wiki/MD5
>https://www.gohacking.com/what-is-md5-hash/

## X11 vs. VNC
VNC 是抓取图像传输，X11 是抓取绘制图像的命令传输，相同环境下X11得到的画面是无损的，并可以节约大量带宽，一种改进的压缩 X11 转发方式称为 NoMachine NX，是 Linux 下最好用的连接方式，类似的技术在 Windows 上就是 RDP。

X11 的劣势似乎是远程用户和本地用户不能共享同一个 sessions，即 X11 登录会启动一个新的 session，而不是接管当前用户正在用的那个，所以不能同时操作，甚至看不到对方的操作；RDP 登录使用的是同一个 session，尽管看不到对方的操作；VNC 使用的是同一个，并且远程和本地可以同时操作。

>来源：http://www.ruanyifeng.com/blog/2011/12/ssh_port_forwarding.html 下的评论

## VPN原理
vpn(Virtual Private Network)在公共网络上，建立一个相距甚远的虚拟局域网。原理是，vpn客户端虚拟一个网卡，vpn服务端虚拟一个NAT设备（相当于路由器），vpn客户端与vpn服务端协商，获得私有ip地址，vpn客户端的请求通过虚拟网卡发送，经由vpn服务端到达目的地，响应再从vpn服务端返回给vpn客户端。

vpn客户端和服务端之间会加密防止数据被窃取，比如在公共wifi中，即使数据被抓包，由于加密过，信息也不会被获取。

vpn服务端相当于虚拟了一个路由器，因此连接同一个vpn服务端的所有vpn客户端处于同一个虚拟局域网中。

vpn服务端这里指的是服务器中的服务，它的虚拟NAT连接在服务器的网卡上，因此，vpn相当于在服务器上建立了一个虚拟网络，可以访问服务的私有网络，但是服务器的私有网络不能访问vpn的私有网络。

>参考：
>[vpn工作原理和搭建方法](https://blog.csdn.net/weixin_42075590/article/details/81025045)

## socks5，shadowsocks
Socket Secure（SOCKS）是一个用代理服务器在客户端和服务端交换数据的网络协议。socks5版本额外提供了授权功能。socks5代理原理简单的说，就是一个**socks代理**作为你的设备和网络的一个桥梁。你发给其他服务器（如web）的请求，会被socks代理（位于本地）转发给**代理服务器**，由代理服务器代替用户向其他服务器发出请求。比如chrome浏览器（支持socks5协议）就可以设置代理，设置后，会将请求交由代理处理。

但是本地发往代理服务器的数据包并不会被加密，因此安全性并不高，但是速度较快。

------------------
shadowsocks是一个基于socks5开源项目，在将流量传给shadowsocks服务器时会加密流量，但是由于shadowsocks的主要目的为了绕行大陆的流量审查，因此加密主要是为了混淆流量达到绕行大陆封锁手段的目的。

vpn也可以用于翻墙，但是由于它的实现机制，会将你所有的流量传给vpn服务器，而shadowsocks可以有**选择性**的代理流量，如国内流量不走代理，国外流量走代理。但是vpn有更安全的加密方式，使你的数据不会被窃取，保证了你的隐私。

shadowsocks是一个代理，需要软件支持socks5和设置代理。windows上，很多软件，如基于chrome内核的浏览器会自动使用系统代理（即IE浏览器的代理设置），因此ss客户端只要设置好系统代理，那么就可以为很多软件代理流量；而在android环境中，ss会依靠vpn来为所有应用代理流量。如果应用不自动使用系统代理，但提供设置功能，可以选择手动设置代理。如果应用不支持设置仍要代理，可以参考方案：[如何用Shadowsocks(R)代理非浏览器软件、游戏][7]

>参考：
>[What Is Socks5 Proxy?](https://www.ibvpn.com/2018/09/what-is-socks5-proxy/)
>[Shadowsocks vs. VPNs — Everything You Need to Know](https://www.vpnmentor.com/blog/shadowsocks-vs-vpns-everything-need-know/)
>[SOCKS wiki](https://en.wikipedia.org/wiki/SOCKS)
>[shadowsocks实现原理](https://bingtaoli.github.io/2016/11/23/shadowsocks%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/)

[7]:https://vimcaw.github.io/blog/2018/03/12/%E5%A6%82%E4%BD%95%E7%94%A8Shadowsocks(R)%E4%BB%A3%E7%90%86%E9%9D%9E%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BD%AF%E4%BB%B6%E3%80%81%E6%B8%B8%E6%88%8F/

## GFW工作原理
Great Firewall(GFW)，即长城防火墙，通过很多技术来监控和过滤互联网内容，主要是在国内与国外的出口网关出进行一系列封锁手段。如下所示：
1. **关键字过滤**：如http是明文传播的，可以轻易获取关键信息，然后过滤请求。
	
	>如果是https呢？还有其他手段。	
	
2. **DNS劫持和污染**：国内运营商的DNS解析域名服务器会劫持非法DNS解析，返回错误ip或干脆不解析，更可恶的是通过DNS劫持来插入自己的广告。国内仅存的F、I两个根域名DNS镜像，由于DNS污染严重，已被与国外断开连接。而我们上网时通过DCHP自动配置的就是运行商的DNS解析服务器，可以手动设置DNS为公共DNS达到绕过DNS劫持、污染的目的。
	
	>通过公共DNS和https能够访问google、youtube吗？不能，还有手段。
	
3. **IP地址封锁**：直接将已知的google、youtube等网站对应的ip地址封锁。这样即使你能够DNS解析到对应ip也不能访问。

4. **特定端口封锁**：封锁ip的缺点很大，因为ipv4紧张，大多都是通过NAT共用一个ip地址，因此采用更“温柔”的手段封锁端口。
	
>试想，在香港或日本租用一个vps，而很多vps共用一个ipv4地址。因为一个人搭建了梯子，导致ip被封，那么其他vps搭建的网站就不能被访问了，很不合理。题外话，，我在国外的服务器经常被封端口。。原因你晓得。。

5. **SSL连接阻断**：SSL协议，位于OSI七层网络模型中的展示层，用于加密传输。目前的翻墙手段都使用加密协议绕过防火墙，交由境外服务器代理转发，达到访问国外手段的目的。但是由于建立加密通道的流量特征太过明显，GFW可以识别到它，然后阻断。目前OpenVPN就被阻断了导致无法使用，而shadowsocks通过固定秘钥的方式放弃复杂的身份认证机制，来伪装普通的tcp流量，达到混淆、绕过GFW的目的。据说GFW正在升级二代，使用人工智能识别shadowsocks流量特征？？！！

6. **随机丢包**：万能的方案，，对于任何流量，一视同仁，随机丢弃，导致国外访问变慢。
	
	>对于搭建梯子而言，可以使用一些加速方案，改进底层协议（如tcp）。如BBR，BBR改进了拥塞控制算法，大大提高了发包速度，加速了梯子，但也间接的加大了整个网络的丢包率，造成整个网络的抖动性加剧。

>参考：
>[GFW](https://en.wikipedia.org/wiki/Great_Firewall)
>https://blog.csdn.net/eerstar/article/details/47866703

## AAA
authentication（认证）, authorization（授权）, and accounting（会计）（**AAA**）指的是控制对资源访问、实施策略、审计和提供收费服务所需的信息的过程。
* **authentication**（认证）：用于识别用户，通常使用姓名和密码认证。
* **authorization**（授权）：是一个实施策略的过程，即何种活动、资源或服务的类型或质量被允许。通常授权发生在认证的过程中，即一旦被认证，就确认了他的权力。
* **accounting**（会计）：统计会话数据和使用信息，用于授权控制、付费、数据分析、资源利用和容量规划活动。

>参考:
>[authentication, authorization, and accounting (AAA)](https://searchsecurity.techtarget.com/definition/authentication-authorization-and-accounting)

## 127.0.0.1 and 0.0.0.0
`127.0.0.0/24`是**loopback address**，通过该地址与本地主机建立连接。这些地址功能都一样，但最常用的是`127.0.0.1`，即**localhost**。可把环路地址看做另一块网卡的ip，外部主机没有办法访问该网卡，因此监听环路地址的服务只能内部访问。

0.0.0.0 是一个不可路由的元地址，用于指定无效的、未知的或不适用的目标。在路由器的环境中，只默认路由；在服务器的环境中，指服务器的所有地址。比如主机有两个ip地址，监听0.0.0.0就相当于同时监听了这两个地址。

>参考:[What is the Difference Between 127.0.0.1 and 0.0.0.0?](https://www.howtogeek.com/225487/what-is-the-difference-between-127.0.0.1-and-0.0.0.0/)

## Net Analyzer

安卓上一款很好的网络检查工具, 其中端口扫描的状态:

* 绿色: 端口打开且有服务运行
* 红色`closed`: 端口打开但无服务
* 灰色`blocked`: 端口未开

## HTTP与SOAP

SOAP是构建于HTTP之上的, **过时的**信息传输协议, 在消息结构的描述上SOAP要好点.


# 前端
## 判断页面是否处于微信环境
```javascript
//判断是否是微信浏览器的函数
function isWeiXin(){
  //window.navigator.userAgent属性包含了浏览器类型、版本、操作系统类型、浏览器引擎类型等信息，这个属性可以用来判断浏览器类型
  var ua = window.navigator.userAgent.toLowerCase();
  //通过正则表达式匹配ua中是否含有MicroMessenger字符串
  if(ua.match(/MicroMessenger/i) == 'micromessenger'){
  return true;
  }else{
  return false;
  }
}
```
## 关闭浏览器缓存
针对像chrome一样内置DevTools的浏览器，打开网络，勾选便是，如下图所示：
![在这里插入图片描述](.零碎知识/20190411221651937.png)
注意！要一直保存弃用缓存的效果，需要一直开着DevTools。

## 代码设置断点
在需要中断的地方加上`debugger`

## CommonJS vs. AMD
CommonJS和AMD都是关于如果定义模块和它们依赖的规格（specification）。
* 由于CommonJS是同步加载的，因此实现适合用在服务端，如Node.js实现了它。
* AMD支持异步模块加载，适合用在浏览器端JS开发，RequireJS实现它。

但不是说AMD不能用在服务端，CommonJS不能用在浏览器端，详细见参考。

>小白见解：尽管ECMAScript是解析式语言，当项目增大时，分模块开发是是否有必要的，无论是服务端（Node.js）还是浏览器端（JavaScript）。在服务端可用CommonJS（Node.js以实现并提供了），浏览器端可用RequireJS。

>小白见解2：未出现模块框架时，常使用匿名函数分隔作用域，来模拟模块；现在ES6提供了模块的功能（import、export关键字），感觉可以远离框架了。。

>参考：
>* [Relation between CommonJS, AMD and RequireJS?](https://stackoverflow.com/a/16522834/10248407)
>* [CommonJS vs AMD vs RequireJS vs ES6 Modules](https://medium.com/computed-comparisons/commonjs-vs-amd-vs-requirejs-vs-es6-modules-2e814b114a0b)

## Gulp vs. Grunt vs. Webpack
这里直接引入stackoverflow的答案，题目：[Difference between build tools and task runners](https://stackoverflow.com/questions/46838104/difference-between-build-tools-and-task-runners)

The main difference is, just as the name suggests:

A **task-runner** like **gulp** or **grunt** is used to define different tasks, define how they are called, in which order they are executed and what dependencies they have. You can configure virtually anything as a task, as long as - in this case - the Node API allows it.

A **build tool** or **bundler** like **webpack** or rollup basically executes a single task: building/bundling. You can use plugins to tell them how to do their job, but you have little control over the order of execution nor can you run specific subsets of the process (like: only transpile the code but don't bundle) in the way a task-runner allows.

Do task-runners and build systems/bundlers fit together? Yes, they do! There are plugins that connect those systems, like **gulp-webpack**. Eitherway, you can always use the Node API from inside your tasks to do whatever you like.

>小白见解：这个工具运行在Node.js的环境下，尽管Node.js是服务端脚本，但常用做开发环境，开发前端项目


>参考：
>* [Difference between build tools and task runners](https://stackoverflow.com/questions/46838104/difference-between-build-tools-and-task-runners)
>* [GULP VS GRUNT VS WEBPACK: COMPARISON OF BUILD TOOLS / TASK RUNNERS](https://da-14.com/blog/gulp-vs-grunt-vs-webpack-comparison-build-tools-task-runners)

>深度阅读：
>
>* [Webpack是答案吗](https://refined-x.com/2017/06/16/Webpack%E6%98%AF%E7%AD%94%E6%A1%88%E5%90%97/)

## Vue、React、Angular
以前都是使用JQuery开发组件，由JQuery主要是用于操控DOM的，并不是为组件而诞生。于是出现了Vue、React、Angular，能够更好的进行组件开发。

## Bootstrap、element ui、vant
都是前端UI解决方案，使用它可以快速搭建网站。element ui和vant都是基于vue编写的，适合于vue一起使用。element ui适合于桌面端ui，vant适合移动端ui。

## Electron

**Electron** (formerly known as **Atom Shell**[[5\]](https://en.wikipedia.org/wiki/Electron_(software_framework)#cite_note-5)) is an [open-source](https://en.wikipedia.org/wiki/Open-source_software) [framework](https://en.wikipedia.org/wiki/Software_framework) developed and maintained by [GitHub](https://en.wikipedia.org/wiki/GitHub).[[6\]](https://en.wikipedia.org/wiki/Electron_(software_framework)#cite_note-6) Electron allows for the development of desktop [GUI](https://en.wikipedia.org/wiki/GUI) applications using web technologies: It combines the [Chromium](https://en.wikipedia.org/wiki/Chromium_(web_browser)) rendering engine and the [Node.js](https://en.wikipedia.org/wiki/Node.js) runtime. 跨平台的.


# 其他

## 大端小端
* **Big-Endian**：具体是指最高位字节在地址最低位、最低位字节在地址最高位的顺序来存储数据
* **Little-Endian**：使用相反的顺序来储存数据。
* 
## CRLF（回车换行）
术语**CRLF**指Carriage Return (ASCII 13, \r)和Line Feed (ASCII 10, \n)。

例子：
 * 在Windows中同时支持**CRLF**和**LF**形式的换行符；
*  在Linux/UNIX中仅支持**LF**形式的换行符；
* http协议中，使用**CRLF**作为换行符；

注意点：
* 目前，很多编辑器都能很好的处理这两种换行方式，除了**bash script**。。
* git在commit时，最好设置自动转化为**LF**形式的换行符
* 其他情况下可以放心用。

>参考：https://github.com/Microsoft/WSL/issues/2318#issuecomment-444531035

## ctrl+F和wrap-around
在使用ctrl+F搜索时会出现wrap-around或wrap-search供选择，它的意思是从光标处开始搜索，直到文档底部，如何还继续寻找，则从文档开始出寻找，直到原先光标的地方，也就是全文档查找。如果不启用，则查到底部则结束。
>Wrap-around means the program will search for the text you specify beginning at the place in the document where you are currently positioned, and will continue past the end, to the beginning of the document back to your current position. In other words, wrap-around search will search the entire document irrespective of where you may be positioned within it. 
>
>If you only want to search to the end of the document, turn off wrap-around search.

## 度量单位
1 `s`=10^3^ `ms`(毫秒)=10^6^ `μs`(微秒)=10^9^ `ns`(纳秒)

## UTC和GMT
UTC和GMT差别不大，但是还是有点小区别的：
>Some computer standards are defined in terms of Greenwich mean time (GMT), which is equivalent to universal time (UT). GMT is the "civil" name for the standard; UT is the "scientific" name for the same standard. The distinction between UTC and UT is that UTC is based on an atomic clock and UT is based on astronomical observations, which for all practical purposes is an invisibly fine hair to split. Because the earth's rotation is not uniform (it slows down and speeds up in complicated ways), UT does not always flow uniformly. Leap seconds are introduced as needed into UTC so as to keep UTC within 0.9 seconds of UT1, which is a version of UT with certain corrections applied. There are other time and date systems as well; for example, the time scale used by the satellite-based global positioning system (GPS) is synchronized to UTC but is not adjusted for leap seconds

>参考：https://docs.oracle.com/javase/8/docs/api/java/util/Date.html

## 单字节编码
ANSI>ISO-8859-1>ASCII

编码方式和编码集是不同概念。

>已发表博客，参考：[字符编码](https://blog.csdn.net/jdbdh/article/details/83651915)

## 闰年
闰年2月有29天，否则28天。能够被4整除不被400整除的年份为闰年。

## chrome app vs. extension
* **app**:It basically says that there are two kinds of apps: **hosted** and **packaged**. Hosted apps are **glorified bookmarks**. But packaged apps provide you with a somewhat best of **both worlds features**- of both extensions and apps.
* **Extensions**: of course extend the core browser functionality providing little or no additional UI apart from what is already provided by chrome.
>相关资料:[Difference between Chrome Apps and Extensions](https://stackoverflow.com/questions/5341206/difference-between-chrome-apps-and-extensions)
>[chrome app vs extension](https://developers.google.com/chrome/web-store/articles/apps_vs_extensions)

## 原、反、补码
负数的补码：从原码右边开始，找到第一个不为1的0，开始全部取反（包括0）。
## N/A
**N/A**或**n/a**是英语“不适用”（Not applicable）等类似单词的缩写，常可在各种表格中看到。

N/A比较多用在填写表格的时候，**表示“本栏目（对我）不适用”**。在没有东西可填写，但空格也不允许此项留白的时候，可以写N/A。在英语国家，也会用n/a或者n.a.来表达，都是同一个意思。
>参考：[N/A wiki](https://zh.m.wikipedia.org/zh-hans/N/A)

## 备案
域名备案其实就是对网站备案。**没有备案的域名照样可以解析**，毕竟阿里、腾讯只是[域名注册商][511]，但要进行实名认证（ICANN规定的）。那么国家为了防止非法网站，都做了什么？
* 云服务器上，会不定期扫描80端口上的流量，由于http是明文传输，因此可以获得域名。如果发现域名没有备案，会阻止流量的通过。
* 在家庭宽带上，电信、移动等通信运营商会封锁80，443端口，即使你进行端口映射，也不能被访问。

如果想非法建站，没有备案下我们可以做什么？
* 在云服务器上，我们可以在非80端口建站；或使用https（443）协议，因为该协议是加密传输的；或使用ip访问，而不是域名。
* 在家庭宽带上，我们可以使用内网穿透工具，如ngrok，来绕过80、443端口。ngrok本质上起着流量转发的作用。
* 使用国外的云主机，域名无所谓国内外，除了cn。
----
然而这些手段还是不要用，终究是不正规的，并且域名备案真的简单。那**个人**域名（网站）备案需要注意的什么？过程如何？
1. 准备身份证、家乡的电话卡
2. 在运营商上的待备案系统上进行备案，填写对应信息
3. 电话、地址填家乡的电话卡和地址，否则你需要去公安准备暂住证。
4. 网站名称最好反应网站内容，并且限制很多，请百度。（阿里工作人员电话核查时帮我改正了）
5. 填写后让阿里邮寄幕布，接收后拍照上传。
6. 等待阿里的电话核查
7. 等待管理局的审核，可能有电话核查。
8. 备案成功，然后在网站首页按照要求写上备案号。

大致应该这些，大致要花上一个星期。


[511]:https://blog.csdn.net/jdbdh/article/details/86694019#35__60

## safe write
一些编辑器中（如vim），会使用safe write来更新文件。过程：与简单的更新文件相反，safe write会写入一个临时文件，然后删除源文件，将临时文件名改成源文件名。

这样会对监听文件修改的程序造成问题。

>参考：[What is the advantage of “safe write” in JetBrains IntelliJ?](https://stackoverflow.com/questions/33815074/what-is-the-advantage-of-safe-write-in-jetbrains-intellij)

## 远程连接
win10自带了远程连接工具，比qq远程好用多了。按`win`，然后输入`快速助手`，或者`quick assist`

## 架构模式（MVVM、MVC）
架构模式的最终目标都是将不同的逻辑分离出来，即逻辑分层，降低项目的复杂性。如业务逻辑与展示层逻辑的分离，某个层逻辑的变动不会造成其他层的变动。

比如后端的MVC（Model-View-Controller）架构中：

- 数据逻辑（Model）：dao、service层处理数据并转化为View可用的Model；

- 交互逻辑（Controller）：controller层处理前端的请求

- 渲染逻辑（View）：将Model渲染成用户可见的视图（html），但前后端分离后，可见View的用户成了前端程序员，因此通常是将Model渲染成Json。

  > 渲染逻辑基本不用自己写逻辑，都有现成的库了，如spring mvc会帮你处理好。

又比如前端的MVVM（Model-View-ViewModel）架构：

- 数据逻辑（Model）：数据获取、处理
- 交互逻辑（ViewModel）：处理用户与View的交互。
- 渲染逻辑（View）：将model渲染到View中。。

为啥MVC和MVVM的目标一样，却又不用的名称呢？可能是大家觉得交互逻辑处理方式不一样，如数据绑定，所以就以名字来区分吧。。

比如说，前端框架Vue基本实现了MVVM，它的ViewModel提供了数据绑定的功能，Model改变时，View则自动改变，无需手动修改View的内容。这样使得程序员更多的专注于组件逻辑的编写，程序的复杂性大大降低。
## 对项目的理解
新建项目后会产生一个含有配置文件的目录，如（idea中的`.idea`）。该文件含有文件编码、编译器、运行配置等等。

新建文件时会选择项目类型，其实就是选择项目模板，为你生成一些必要的项目文件（或目录结构来着）。类似于vue的脚手架。

配置运行时配置时，需要选择运行模板，其实就是根据你配置的参数运行配置好的命令罢了。如果运行模板与你的项目类型不对应，则跑步起来，即特定运行模板才能识别你的项目类型。

配置好后，这些配置都会存在于项目的配置文件中。在一些前端项目中，几乎可以不需要idea这样的集成开发环境，比如Vue，因此vue项目的产生、编译、运行都很简单。

vue想与idea集成，也很简单，项目生产、编译、运行都可靠命令，只需要idea装上插件，能够识别vue文件并给出提示即可。

## 输入法

- 全角占两个标准（半角）字符的位置，主要为了使格式排列规整。一般输入法在汉字输入下，默认英文半角，中文字符和中文标点全角。

  > 输入法中的**全半角切换**可切换英文标点模式。

- 每个键位的码值还是由输入法决定的。

  > 输入法中的**中英文切换**可切换英文码值。

## 其他邮箱登录Google账号

1. 进入[Google账号](https://myaccount.google.com/personal-info)

2. 点击**个人信息**
3. 点击**联系信息**下的**电子邮件**
4. 设置好**辅助电子邮件地址**

之后便可以通过辅助电子邮件地址来登录Google账号了.