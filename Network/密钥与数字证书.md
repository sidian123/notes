# 秘钥&加密算法

秘钥（**key**）通过加密算法（**key algorithms**）生成。

加密算法分为两类：

* 对称秘钥加密算法（**symmetric key algorithms**）
* 非对称秘钥加密算法（**asymmetric key algorithms**）。

前者属于单钥加密（**private key cryptography**），只产生一把秘钥，由该秘钥加密和解密，拥有秘钥的双方都需要保管好秘钥，因此秘钥容易被泄漏出去；而后者属于双钥加密（**public key cryptography**），产生两把秘钥，一把公开的公钥（**public key**），一把不公开的私钥（**private key**），只需要保管好私钥，安全性大大提高了 。

在双钥加密的情况下

* 公钥和私钥一一对应，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。
* 所有的（公钥, 私钥）对都是不同的。
* 公钥可以解开私钥加密的信息，反之亦然；但不能解开自己加密的信息。公钥一般用于加密，私钥一般用于解密。
* 秘钥对生成后，不能从公钥推出私钥，在原理上也不能从私钥推出公钥，但是由于一般私钥中也会保存公钥的信息，因此可行，如`ssh-keygen -y`

目前，通用的单钥加密算法为`DES`（Data Encryption Standard），通用的双钥加密算法为`RSA`（ Rivest-Shamir-Adleman），都产生于上个世纪70年代。

> 单钥加密算法还有`AES`（微信公众号正在使用）,`HMAC`等
>
> 双钥加密算法还有`DSA`,`ECDSA,ED25519`,`ECDSA`等。

# HTTPS安全剖析

浏览器与服务器使用`https`通信时，通信过程如下（这里的步骤2是错误的）：

1. 浏览器向服务器发出请求。 

2. 服务器发送公钥给浏览器，之后双方都通过秘钥对数据加密和解密。

3. 服务器将浏览器请求的数据通过**哈希函数**，产生**摘要**（digest），然后用私钥对摘要进行加密，产生**数字签名**（signature），并将数据连同数字签名发给浏览器。

   > 常用于生成摘要的哈希算法有`md5`，参考：[零碎知识4.6小节][1]

4. 浏览器使用公钥解密数字签名，得到摘要，然后也对数据进行哈希运行产生摘要，将两者对比，判断是否来自于要访问的服务器，然后执行自己的操作。

5. 两者继续通过秘钥通信

但是问题来了，步骤1、2中，浏览器请求服务器时，请求被hacker拦截，并模拟服务器发送自己的公钥给浏览器，于是hacker可以通过自己的私钥来骗取浏览器的信任，容易窃取到浏览器用户的信息。这就是著名的[中间人攻击][2]。

也就是说，浏览器获得的公钥不可信。为了解决此问题，引入了大家都信任的**数字证书认证机构（CA）** ，CA用自己的私钥将服务器一些相关信息和公钥加密起来形成**数字证书**。于是步骤2中，服务器不再发送公钥给浏览器，而是发送数字证书。浏览器一般会保存被信任的所有认证机构（CA）的公钥，用于解密收到的数字证书，得到服务器的公钥，再进行步骤4进行验证。

只要CA的私钥不被泄漏，hacker就不能伪造数字证书，从而不能将自己的公钥传给浏览器。即使hacker获取了其他服务器的私钥和数字证书，拦截浏览器请求交给它该数字证书，浏览器也判断该证书代表的服务器不是自己访问的，因为数字证书中还含有与服务器相关的信息。

> 若hacker充当代理的角色, 那么链接仍不是正常的. 因为代理中传输数据, hacker相当于是透明的, hacker可以随时获取和串改数据. 这就是为啥使用别人的VPN, SS科学上网不安全的原因.

这就是https能够保证数据安全的原因。

[1]:https://blog.csdn.net/jdbdh/article/details/87189717#46_md5_258
[2]:http://en.wikipedia.org/wiki/Man-in-the-middle_attack

# TLS

## 介绍

SSL*(Secure Socket Layer 安全套接层)* 是HTTPS下的协议加密层, 之后SSL3.1更名为TLS*(Transport Layer Security 安全传输协议)* .

用于在两个通信应用间建立安全传输的通道.

## 协议过程

大致过程如下

* 首先客户端与服务器端握手，其中包含有协商的加密套件、随机数等信息；

* 服务器向终端下发证书，终端进行证书校验，判断其是否可信；

* 如果要求双向认证，则客户端也需要向服务器提供证书，服务器根据证书进行校验，从而确认终端身份

* 客户端与服务器端分别利用证书中的公钥以及服务器端保存的私钥进行加密密钥协商

* 完成之后即可根据协商好的加密算法、摘要算法以及秘钥进行数据加密传输并保证其完整性。

主要涉及点

1. 证书的基础知识与如何生成
2. 如何进行TLS双向认证
3. 如何选择相应的加密套件

# 证书

## 基本知识

* 证书

  是签发方信息, 拥有者信息, 公钥(或者+私钥), 签名（由签发方私钥签名）以及其他额外信息的集合

* 签名

  用私钥对数据摘要加密后的结果

* 证书作用

  校验发送方的信息(一般为公钥)是否可靠

* 如何保证证书可信

  当前证书是否可信, 可通过证书的上层签发方的证书校验, 上层证书又需上上层证书判断是否可信, 直到遇到根证书, 根证书是绝对可信的, 于是形成了一条**证书链**.  

  最顶层的证书, 就是**根证书**, **根证书绝对可信**; 其他的为**中间证书**, 需要校验是否可信. 

  一般电脑中已内置了一些根证书和中间证书. 也可以自己添加证书.
  
  > 访问银行网站时需要安装的证书, 应该就是中间证书了吧

## 证书相关文件

证书相关的文件很多, 存储的信息也不同, 文件以不同扩展名区分:

* crt

  常见于*nix系统，大多是PEM编码，也可能是DER编码

* cer

  常见于Windows系统，大多是DER编码，也可能是PEM编码

* key

  用户存放密钥信息，和证书一样，可能是DER编码，也可能是PEM编码；可参照PKCS#1（RFC8017）查看其具体字段和定义；但密钥明文存储方式有所危险，一般可以使用PKCS#8格式（RFC5958）进行密钥的加密，即设置一个提取密钥

* csr

  证书签发请求，其实与证书内容相似，但不包含签发方信息，签发方根据CSR并添加自身的签发信息，从而生成证书文件，详情可参照（PKCS#10 RFC2314）

* pfx/p12

  实际上就是将证书和私钥一并打包成一个文件，并且设置“提取密码”

* jks/keystore/truststore

   一般常见于JAVA相关应用，实际上也是和p12类似，将证书和私钥一并打包并设置“提取密码”，至于keystore和truststore只是概念上的区别，keystore一般用户表示用户或服务器证书，而truststore一般表示CA证书

## Android证书

* 介绍

  Android使用的jks证书, 包含证书和私钥. 并且Android证书的签发方和拥有发都是自己设置的, 即自签的证书.

* 证书用途

  保证更新后的APK与手机内安装的APK的拥有者是同一个. 

* 如何保证

  * 当用户安装了已签名的APK后, **即表示用户信任了该证书**. 也无需其他证书保证该证书.

  * 当用户更新APK时, 用之前信任的证书中的公钥, 来判断要更新的应用的证书是否可信. 

    > 具体判断算法我不知道

  > 主要思想是, 用户安装了APK, 代表信任了它的证书, 可通过该证书的公钥判断其他证书是否可信. 因为其他人不知道私钥, 当数据改变后, 无法生成正确的签名.

* 证书指纹

  就是数字签名. 在Android中, 数字签名(证书指纹) + 包名, 唯一确定一个APK应用.

* 证书生成

  使用JDK的`keytool`生成, 但使用Android Studio的界面使用更为方便

  在`build > generate signed Bundle / APK`中添加证书信息

  ![image-20200605161033707](.%E5%AF%86%E9%92%A5%E4%B8%8E%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/image-20200605161033707.png)

> [证书番外篇之Android证书](https://blog.csdn.net/jjxojm/article/details/81395573)
>
> [Android开发者证书的创建](https://blog.csdn.net/nahancy/article/details/89485962)

# 其他

## .pem vs. .pub

* `.pem`和`.pub`都是密码, 其中`.pem`可以是公钥也可以是私钥, 而`.pub`只能是公钥
* 只要用户有远程主机认可的私钥, 用户就可从不同主机上登录

> 参考[.pem密钥和.pub密钥有什么区别？](https://segmentfault.com/q/1010000011335632)

# 参考

* 入门阅读
  * [密码学笔记](http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html)
  * [数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)
  * [Key (cryptography)](https://en.wikipedia.org/wiki/Key_(cryptography))
  * [ssh-keygen](https://www.ssh.com/ssh/keygen/)
* 证书进阶
  * [HTTPS、SSL、TLS三者之间的联系和区别](https://blog.csdn.net/enweitech/article/details/81781405)
  * [关于证书链的一点认知](https://www.jianshu.com/p/fcd0572c4765)
  * [根证书与中间证书的区别](https://www.sohu.com/a/250886697_708801)
  * [TLS初探（1）概述](https://blog.csdn.net/jjxojm/article/details/81266181)
  * [TLS初探（2）证书简介](https://blog.csdn.net/jjxojm/article/details/81266601)
  * [TLS 百科](https://baike.baidu.com/item/TLS/2979545?fr=aladdin)
  * [证书番外篇之Android证书](https://blog.csdn.net/jjxojm/article/details/81395573)

# 进阶阅读

* [加密算法(DES,AES,RSA,MD5,SHA1,Base64)比较和项目应用](https://www.cnblogs.com/sochishun/p/7028056.html)

