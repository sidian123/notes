# 基础

## 介绍

SSL*(Secure Socket Layer 安全套接层)* 是HTTPS下的协议加密层, 之后SSL3.1更名为TLS*(Transport Layer Security 安全传输协议)* .

用于在两个通信应用间建立安全传输的通道.

## 协议过程

大致过程如下

* 首先客户端与服务器端握手，其中包含有协商的**加密套件**、随机数等信息；
* 服务器向终端下发证书，终端进行**证书**校验，判断其是否可信；
* 如果要求双向认证，则客户端也需要向服务器提供证书，服务器根据证书进行校验，从而确认终端身份
* 客户端与服务器端分别利用证书中的**公钥**以及服务器端保存的**私钥**进行**会话密钥**协商
* 完成之后即可根据协商好的加密算法、摘要算法以及密钥进行数据加密传输并保证其完整性。

![image-20200824143531182](.TLS/image-20200824143531182.png)

> 参考https://crypto.stackexchange.com/a/27133

# 加密算法

## 密钥

密钥（**key**）由加密算法（**key algorithms**）生成。

加密算法分为两类：

* 对称密钥加密算法（**symmetric key algorithms**）
* 非对称密钥加密算法（**asymmetric key algorithms**）。

前者属于单钥加密（**private key cryptography**），只产生一把密钥，由该密钥加密和解密，拥有密钥的双方都需要保管好密钥，因此密钥容易被泄漏出去；而后者属于双钥加密（**public key cryptography**），产生两把密钥，一把公开的公钥（**public key**），一把不公开的私钥（**private key**），只需要保管好私钥，安全性大大提高了 。

在双钥加密的情况下

* 公钥和私钥一一对应，有一把公钥就必然有一把与之对应的、独一无二的私钥，反之亦成立。
* 所有的（公钥, 私钥）对都是不同的。
* 公钥可以解开私钥加密的信息，反之亦然；但不能解开自己加密的信息。公钥一般用于加密，私钥一般用于解密。
* 密钥对生成后，不能从公钥推出私钥，在原理上也不能从私钥推出公钥，但是由于一般私钥中也会保存公钥的信息，因此可行，如`ssh-keygen -y`

## 加密算法

* 对称加密算法

  * **DES**（Data Encryption Standard）：数据加密标准，速度较快，适用于加密大量数据的场合。

  * **3DES**（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。

  * **AES**（Advanced Encryption  Standard）：高级加密标准，是下一代的加密算法标准，速度快，安全级别高；AES是一个使用128为分组块的分组加密算法，分组块和128、192或256位的密钥一起作为输入，对4×4的字节数组上进行操作。众所周之AES是种十分高效的算法，尤其在8位架构中，这源于它面向字节的设计。AES  适用于8位的小型单片机或者普通的32位微处理器,并且适合用专门的硬件实现，硬件实现能够使其吞吐量（每秒可以到达的加密/解密bit数）达到十亿量级。同样，其也适用于RFID系统。

    > 微信公众号用的该算法认证.

* 非对称加密算法

  * **RSA**：由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的。RSA在国外早已进入实用阶段，已研制出多种高速的RSA的专用芯片。

  * **DSA**（Digital Signature Algorithm）：数字签名算法，是一种标准的 DSS（数字签名标准），严格来说不算加密算法。

  * **ECC**（Elliptic Curves  Cryptography）：椭圆曲线密码编码学。ECC和RSA相比，具有多方面的绝对优势，主要有：抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。计算量小，处理速度快。ECC总的速度比RSA、DSA要快得多。存储空间占用小。ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在IC卡上的应用具有特别重要的意义。带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时ECC带宽要求却低得多。带宽要求低使ECC在无线网络领域具有广泛的应用前景。

  还有`ECDSA,ED25519`,`ECDSA`等.

> 对称加密速度快, 适合大量数据加密; 非对称加密算法安全性高, 但速度较慢.

## 其他算法

* 散列算法

  又称哈希算法, 是一种单向加密, 不可逆的算法. 散列算法对不同长度的数据输入, 产生固定长度的输出, 即**摘要**. 摘要通常用作验证数据完整性, 验证数据是否被修改等. 具体用图如: 文件校验, 数据签名, 鉴权协议.

  常见算法有:

  * **MD5**: 不可逆的加密算法, 任何输入都产生一段固定128位二进制的散列值.
  * **SHA1**: 是由NISTNSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为**160bit**的散列值，因此抗穷举(brute-force)性更好。SHA-1设计时基于和MD4相同原理,并且模仿了该算法。SHA-1是由美国标准技术局（NIST）颁布的国家标准，是一种应用最为广泛的Hash函数算法，也是目前最先进的加密技术，被政府部门和私营业主用来处理敏感的信息。而SHA-1基于MD5，MD5又基于MD4。
  * **HMAC**: 是密钥相关的哈希运算消息认证码（Hash-based Message Authentication  Code）,HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。也就是说HMAC是需要一个密钥的。所以，HMAC_SHA1也是需要一个密钥的，而SHA1不需要。

 * **Base64**

   Base64是一种**编码**算法, 并非加密解密算法. 可以将二进制数据编码为64个可打印字符. 常用于HTTP, MIME协议下少量数据的快速传输. 

   标准的Base64并不适合直接在URL中传输, 因为Base64的`/`,`+`字符在URL中需要再次编码, 因此出现了Base64的一些变体, 如Base62.

# 证书

## 基本知识

* 证书

  是签发方信息, 拥有者信息, 公钥(或者+私钥), 签名（由签发方私钥签名）以及其他额外信息的集合

* 签名

  用私钥对数据摘要加密后的结果

* 证书作用

  校验发送方的信息(一般为公钥)是否可靠

* 如何保证证书可信

  当前证书是否可信, 可通过证书的上层签发方的证书校验, 上层证书又需上上层证书判断是否可信, 直到遇到根证书, 根证书是绝对可信的, 于是形成了一条**证书链**.  

  最顶层的证书, 就是**根证书**, **根证书绝对可信**; 其他的为**中间证书**, 需要校验是否可信. 

  一般电脑中已内置了一些根证书和中间证书. 也可以自己添加证书.

  > 访问银行网站时需要安装的证书, 应该就是中间证书了吧

## 证书相关文件

证书相关的文件很多, 存储的信息也不同, 文件以不同扩展名区分:

* crt

  常见于*nix系统，大多是PEM编码，也可能是DER编码

* cer

  常见于Windows系统，大多是DER编码，也可能是PEM编码

* key

  用户存放密钥信息，和证书一样，可能是DER编码，也可能是PEM编码；可参照PKCS#1（RFC8017）查看其具体字段和定义；但密钥明文存储方式有所危险，一般可以使用PKCS#8格式（RFC5958）进行密钥的加密，即设置一个提取密钥

* csr

  证书签发请求，其实与证书内容相似，但不包含签发方信息，签发方根据CSR并添加自身的签发信息，从而生成证书文件，详情可参照（PKCS#10 RFC2314）

* pfx/p12

  实际上就是将证书和私钥&公钥一并打包成一个文件，并且设置“提取密码”

* jks/keystore/truststore

  一般常见于JAVA相关应用，实际上也是和p12类似，将证书和私钥一并打包并设置“提取密码”，至于keystore和truststore只是概念上的区别，keystore一般用户表示用户或服务器证书，而truststore一般表示CA证书

# 实战案例

## HTTPS安全剖析

浏览器与服务器使用`https`通信时，通信过程如下（这里的步骤2是错误的）：

1. 浏览器向服务器发出请求。 

2. 服务器发送公钥给浏览器，之后双方都通过密钥对数据加密和解密。

3. 服务器将浏览器请求的数据通过**哈希函数**，产生**摘要**（digest），然后用私钥对摘要进行加密，产生**数字签名**（signature），并将数据连同数字签名发给浏览器。

   > 常用于生成摘要的哈希算法有`md5`，参考：[零碎知识4.6小节][1]

4. 浏览器使用公钥解密数字签名，得到摘要，然后也对数据进行哈希运行产生摘要，将两者对比，判断是否来自于要访问的服务器，然后执行自己的操作。

5. 两者继续通过密钥协商, 得到一个对称密钥, 用于后续数据加密传输.

   > 因为对称密钥加密解密速度快.

但是问题来了，步骤1、2中，浏览器请求服务器时，请求被hacker拦截，并模拟服务器发送自己的公钥给浏览器，于是hacker可以通过自己的私钥来骗取浏览器的信任，容易窃取到浏览器用户的信息。这就是著名的[中间人攻击][2]。

也就是说，浏览器获得的公钥不可信。为了解决此问题，引入了大家都信任的**数字证书认证机构（CA）** ，CA用自己的私钥将服务器一些相关信息和公钥加密起来形成**数字证书**。于是步骤2中，服务器不再发送公钥给浏览器，而是发送数字证书。浏览器一般会保存被信任的所有认证机构（CA）的公钥，用于解密收到的数字证书，得到服务器的公钥，再进行步骤4进行验证。

只要CA的私钥不被泄漏，hacker就不能伪造数字证书，从而不能将自己的公钥传给浏览器。即使hacker获取了其他服务器的私钥和数字证书，拦截浏览器请求交给它该数字证书，浏览器也判断该证书代表的服务器不是自己访问的，因为数字证书中还含有与服务器相关的信息。

> 若hacker充当代理的角色, 那么链接仍不是正常的. 因为代理中传输数据, hacker相当于是透明的, hacker可以随时获取和串改数据. 这就是为啥使用别人的VPN, SS科学上网不安全的原因.

这就是https能够保证数据安全的原因。

[1]:https://blog.csdn.net/jdbdh/article/details/87189717#46_md5_258
[2]:http://en.wikipedia.org/wiki/Man-in-the-middle_attack

## Android证书

* 介绍

  Android使用的jks证书, 包含证书和私钥&公钥. 并且Android证书的签发方和拥有发都是自己设置的, 即自签的证书.

* 证书用途

  保证更新后的APK与手机内安装的APK的拥有者是同一个. 

* 如何保证

  * 当用户安装了已签名的APK后, **即表示用户信任了该证书**. 也无需其他证书保证该证书.

  * 当用户更新APK时, 用之前信任的证书中的公钥, 来判断要更新的应用的证书是否可信. 

    > 具体判断算法我不知道

  > 主要思想是, 用户安装了APK, 代表信任了它的证书, 并且能够获取到公钥, 接着通过该证书的公钥可判断其他证书是否可信. 因为其他人不知道私钥, 当数据改变后, 无法生成正确的签名.

* 证书指纹

  就是数字签名. 在Android中, 数字签名(证书指纹) + 包名, 唯一确定一个APK应用.

* 证书生成

  使用JDK的`keytool`生成, 但使用Android Studio的界面使用更为方便

  在`build > generate signed Bundle / APK`中添加证书信息

  ![image-20200605161033707](.%E5%AF%86%E9%92%A5%E4%B8%8E%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6/image-20200605161033707.png)

> [证书番外篇之Android证书](https://blog.csdn.net/jjxojm/article/details/81395573)
>
> [Android开发者证书的创建](https://blog.csdn.net/nahancy/article/details/89485962)

# 参考

* 入门阅读
  * [密码学笔记](http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html)
  * [数字签名是什么？](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)
  * [Key (cryptography)](https://en.wikipedia.org/wiki/Key_(cryptography))
  * [ssh-keygen](https://www.ssh.com/ssh/keygen/)
* 证书进阶
  * [HTTPS、SSL、TLS三者之间的联系和区别](https://blog.csdn.net/enweitech/article/details/81781405)
  * [关于证书链的一点认知](https://www.jianshu.com/p/fcd0572c4765)
  * [根证书与中间证书的区别](https://www.sohu.com/a/250886697_708801)
  * [TLS初探（1）概述](https://blog.csdn.net/jjxojm/article/details/81266181)
  * [TLS初探（2）证书简介](https://blog.csdn.net/jjxojm/article/details/81266601)
  * [TLS 百科](https://baike.baidu.com/item/TLS/2979545?fr=aladdin)
  * [证书番外篇之Android证书](https://blog.csdn.net/jjxojm/article/details/81395573)
* HTTP交互过程
  * [深入浅出HTTPS的交互过程](https://www.jianshu.com/p/42e1c073c142)
  * [https交互过程](https://www.jianshu.com/p/d45b1d9e9d13)
* 加密进阶阅读
  * [加密算法(DES,AES,RSA,MD5,SHA1,Base64)比较和项目应用](https://www.cnblogs.com/sochishun/p/7028056.html)

