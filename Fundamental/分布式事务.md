> 文章来源于以下链接, 但内容已有调整或大改.
> 
> 作者：李松
> 链接：https://zhuanlan.zhihu.com/p/41891052

# 前言

不知道你是否遇到过这样的情况，去小卖铺买东西，付了钱，但是店主因为处理了一些其他事，居然忘记你付了钱，又叫你重新付。又或者在网上购物明明已经扣款，但是却告诉我没有发生交易。这一系列情况都是因为没有事务导致的。这说明了事务在生活中的一些重要性。有了事务，你去小卖铺买东西，那就是一手交钱一手交货。有了事务，你去网上购物，扣款即产生订单交易。

## 事务的具体定义

事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制。

## 数据库本地事务

### ACID

说到数据库事务就不得不说，数据库事务中的四大特性，ACID:

- 原子性(**A**tomicity)

一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

就像你买东西要么交钱收货一起都执行，要么要是发不出货，就退钱。

- 一致性(**C**onsistency)

事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。

- 隔离性(**I**solation)

指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。

打个比方，你买东西这个事情，是不影响其他人的。

- 持久性(**D**urability)

指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。

打个比方，你买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。

### InnoDB实现原理

InnoDB是mysql的一个存储引擎，大部分人对mysql都比较熟悉，这里简单介绍一下数据库事务实现的一些基本原理，在本地事务中，服务和资源在事务的包裹下可以看做是一体的:

![img](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/v2-81ee35856a8bb078471ba9ab5e5b3de6_b.jpg)

我们的本地事务由资源管理器进行管理: 

![img](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/v2-fc1017908579c824a079e3af1132dba1_b.jpg)

而事务的ACID是通过InnoDB日志和锁来保证。事务的隔离性是通过数据库锁的机制实现的，持久性通过redo log（重做日志）来实现，原子性和一致性通过Undo log来实现。

UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

 和Undo Log相反，RedoLog记录的是新数据的备份。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。 对具体实现过程有兴趣的同学可以去自行搜索扩展。

# 分布式事务

## 什么是分布式事务

分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

## 分布式事务产生的原因

从上面本地事务来看，我们可以看为两块，一个是service产生多个节点，另一个是resource产生多个节点。

### Service多个节点

随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，举个简单的例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护 

![img](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/v2-2225f188ff48e0ad262fd7fd80c99a67_b.jpg)

 这样的话就无法保证积分扣减了之后，优惠券能否扣减成功。

### Resource多个节点

同样的，互联网发展得太快了，我们的Mysql一般来说装千万级的数据就得进行分库分表，对于一个支付宝的转账业务来说，你给的朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。 

![img](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/v2-ffae01dfc1668fe5e7cee463f26b67b9_b.jpg)



## 分布式事务的基础

从上面来看分布式事务是随着互联网高速发展应运而生的，这是一个必然的我们之前说过数据库的ACID四大特性，已经无法满足我们分布式事务，这个时候又有一些新的大佬提出一些新的理论:

### CAP

CAP定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是你的入门理论。

- C (一致性):对某个指定的客户端来说，读操作能返回最新的写操作。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。
- A (可用性)：非故障的节点在合理的时间内返回合理的响应(不是错误和超时的响应)。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。
- P (分区容错性):当出现网络分区后，系统能够继续工作。打个比方，这里个集群有多台机器，有台机器网络出现了问题，但是这个集群仍然可以正常工作。

熟悉CAP的人都知道，三者不能共有，如果感兴趣可以搜索CAP的证明，在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。

对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。

对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。

顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。

### BASE

BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。是对CAP中AP的一个扩展

1. 基本可用:分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。
2. 软状态:允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是CAP中的不一致。
3. 最终一致:最终一致是指经过一段时间后，所有节点数据都将会达到一致。

BASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。

## 幂等性

**幂等性**就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，**不会因为多次点击而产生了副作用**。

举个最简单的例子，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时不应该进行第二次扣款。

俗一点的理解, 防止请求方抽风, 重复调用一个接口, 导致执行方重复执行, 如扣钱. 

# 分布式事务解决方案

有了上面的理论基础后，这里介绍开始介绍几种常见的分布式事务的解决方案。

## 是否真的要分布式事务

在说方案之前，首先你一定要明确你是否真的需要分布式事务？

上面说过出现分布式事务的两个原因，其中有个原因是因为微服务过多。我见过太多团队一个人维护几个微服务，太多团队过度设计，搞得所有人疲劳不堪，而微服务过多就会引出分布式事务，这个时候我不会建议你去采用下面任何一种方案，而是请把需要事务的微服务聚合成一个单机服务，使用数据库的本地事务。因为不论任何一种方案都会增加你系统的复杂度，这样的成本实在是太高了，千万不要因为追求某些设计，而引入不必要的成本和复杂度。

如果你确定需要引入分布式事务可以看看下面几种常见的方案。

## 2PC

### XA

说到2PC就不得不聊数据库分布式事务中的 XA Transactions。 

![img](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/v2-f296cc98eb448a9abc0869acb1af2534_b.jpg)

在XA协议中分为两阶段:

* 第一阶段

  事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并回复是否可以提交.

* 第二阶段

  事务协调器要求每个数据库提交数据，或者回滚数据。

优缺点

* 优点 

  尽量保证了数据的**强一致性**，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持。

* 缺点
  * 单点问题

    事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。

  * 同步阻塞

    在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。

  * 数据不一致

    两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。

总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。

### Seata的AT

![image-20200523090227859](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200523090227859.png)

## 分治法

整体事务由TM协调, 所有子事务成功, 则整体事务成功; 若某个子事务失败, 则对应事务重试, 或其他已完成事务补偿.

> 补偿, 即撤销该事务执行的结果.

### Saga事务

* 核心思想

  将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据恢复策略进行补偿或重试.

* 定义&操作

  每个Saga事务由多个*子事务*`Ti`组成, 每个`Ti`都对应一个补偿操作`Ci`. 其中补偿操作用于撤销`Ti`造成的结果.

  那么Saga事务的执行顺序如下:

  * 子事务全部完成

    ```
    T1, T2, T3, ..., Tn   其中 Tn 代表最后一个事务
    ```

  * 某个子事务失败, 执行补偿

    ```
    T1, T2, ..., Tj, Cj,..., C2, C1   其中0 < j < n , Tj是发生错误的子事务
    ```

    目的将整个Saga事务执行结果撤销

  * 某个子事务失败, 进行重试

    ```
    T1, T2, ..., Tj(失败), Tj(重试),..., Tn   其中 Tj 是发生错误的子事务
    ```

    适用于必须要执行成功的场景

* 保证隔离性

  * 问题

    假设一场景, 执行子事务T1,T2,T3, T3失败, 需要T1,T2补偿. 此时T1的结果已经被其他事务消费

  * 解决方案

    协调器为整体事务加个锁.

* 现有解决方案

  华为的servicecomb

### TCC

关于TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。

 TCC事务机制相比于上面介绍的XA，解决了其几个缺点: 

1. 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
2. 同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。 
3. 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性 

TCC的执行过程:

![img](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/v2-68e2e27350962356d2b6659f6b9bd631_b.jpg)

对于TCC的解释:

- Try阶段
  
  *主业务服务* 向*业务活动管理器* 登记业务活动, 调用 *从业务服务器* 的`try`方法, 完成所有业务检查, 预留(冻结)必需的业务资源, 以保证整体事务的隔离性.
  
- Confirm阶段
  
  若成功预留资源, *业务活动管理器* 将调用 与业务相关的所有*从业务服务* 的`confirm`方法. 执行真正的业务，且不作任何业务检查，只使用Try阶段预留的业务资源.
  
  Confirm操作满足幂等性，Confirm失败后需要进行重试。
  
- Cancel阶段
  
  若预留资源失败, *业务活动管理器* 将取消与业务相关的所有*从业务服务* 的执行结果，释放Try阶段预留的业务资源. 
  
  Cancel操作需满足幂等性, Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。

举个简单的例子

> 如果你用100元买了一瓶水， Try阶段:你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。
>
> 如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。
>
> 如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)

对于TCC来说适合一些:

- 强隔离性，严格一致性要求的活动业务。
- 执行时间较短的业务

>  实现参考:ByteTCC:[https://github.com/liuyangming/ByteTCC/](https://link.zhihu.com/?target=https%3A//github.com/liuyangming/ByteTCC/)

## 凭证

* 交互方式 

  两方交互, 发送方发送事务完成的凭证(或消息), 接收方通过该消息指定自己的事务, 并修改凭证状态.

* 一致性保证

  * 发送方

    发送方事务完成, 凭证生成; 发送方事务失败, 凭证生成失败

  * 接受方

    接收方事务完成, 凭证状态更改; 事务失败, 凭证状态未变.

    > 凭证状态改变, 标志整体事务完成
  
  > 即凭证的改变, 标志着一方事务的成功. 若不成功, 则重试, 或人工介入

### 本地消息表

* MQ知识回顾

  MQ通过生产者, 消费者确认, 能可靠的传递消息. 但不能保证生产者方的一致性, 如MQ收到消息, 并向生产者发送确定, 但生产者宕机了, 导致未收到确认消息.

  在本地消息表方案中, 即使MQ生产者的一致性不能保证, 但可以保证整体事务的一致性.

  > RocketMQ可以保证生产者方的一致性, 见下节的*MQ事务*.

* 执行过程

  1. **在同一事物中**, 发送方写业务数据和消息数据到DB中, 消息数据代表着业务的发生.

  2. 定时扫描DB中的消息数据, 若业务未完成状态, 则发送消息给接收方.
  3. 接收方消费消息, 若事务失败, MQ将重发. 需保证幂等性

* 一致性保证

  生产者端在接受确认时宕机, 则重启后因本地消息未完成, 将再次发送相同消息. 但只要消费者端具有幂等性, 则能保证整体事务数据一致性.

  消费者端若事务失败, 那么MQ消息不会被确认, 因此会接着自动重试, 或直接人工介入

### MQ事务

在RocketMQ中实现了分布式事务，实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部，

下面简单介绍一下MQ事务，

![img](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/v2-a0caca38ef3d173dc3e831274c0f2614_b.jpg)

基本流程如下: 

* 第一阶段

  发送*消息*到MQ

* 第二阶段

  执行本地事务。

* 第三阶段

  找到MQ中的*消息*, 并修改状态到已完成。此时, 消费者被允许消费该消息.

如何保证一致性:

* 若*确认消息发送* 失败

  RocketMq Broker会定时扫描消息状态，若消息未得到发送者确认，会通知发送者，询问是否提交了. 

  > 在rocketmq中是以listener的形式通知发送者，来做处理。 

* 若消费超时

  则需要一直重试，消息接收端需要保证幂等。

* 若消息消费失败

  这个就需要人工进行处理，因为这个概率较低，如果为了这种小概率时间而设计这个复杂的流程反而得不偿失

![img](.%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/v2-421082c966f10bf51c0748fdae2a06a9_b.jpg)

> 其他MQ未提供分布式事务功能, 怎么办? 见上小节本地消息表方案.

> 详细参考[MQ 实现分布式事务](https://blog.csdn.net/fd2025/article/details/79863390)

# 最后

还是那句话，能不用分布式事务就不用，如果非得使用的话，结合自己的业务分析，看看自己的业务比较适合哪一种，是在乎强一致，还是最终一致即可。最后在总结一些问题,大家可以下来自己从文章找寻答案:

1. ACID和CAP的 CA是一样的吗？
2. 分布式事务常用的解决方案的优缺点是什么？适用于什么场景？
3. 分布式事务出现的原因？用来解决什么痛点？

如果喜欢我们的文章的话，请加我扣扣，来和我一起讨论学习吧。

# 好文待看

* [由Seata看分布式事务取舍](https://www.jianshu.com/p/917cb4bdaa03)

