# 介绍

## MQ使用场景

主要用于系统间解耦, 异步, 削峰.

> 下面都假设传统模式通过Rest API访问, 中间件模式使用MQ队列访问

### 解耦

* 传统模式

  ![img](.Message%20Queue/o_jieou5.png)

  系统间相互调用, 耦合度太高, 牵一发而动全身

* 中间件模式

  ![img](.Message%20Queue/o_jieou6.png)

  通过中间件约定好一个协议, 生产者将消息存入队列, 消费者自行订阅, 业务改变时无需生产者修改, 到达解耦的目的

### 异步

* 传统模式

  ![img](.Message%20Queue/o_yibu2.png)

  系统间同步运行, 一次请求需要所有系统完成才结束, 每个系统完成的时间不一样, 导致部分系统闲置, 且响应速度慢.

* 中间件模式

  ![img](.Message%20Queue/o_yibu3.png)

  消费者以订阅的方式获取数据, 即自己空闲了即可去获取数据, 消费者不必等待所有其他系统的完成, 极大提高了资源利用率的同时, 也加快了生产者响应的速度.

### 削峰

* 传统模式

  ![img](.Message%20Queue/o_xuefeng1.png)

  请求时边写入数据库, 造成数据库压力山大

* 中间件模式

  ![img](.Message%20Queue/o_xuefeng2.png)

  请求缓存到队列中, 系统以异步的方式写入数据, 不慌不忙, 给数据库减压

## MQ的缺点

* 降低整体系统可用性: 消息队列挂了, 系统就不可用了
* 增加系统复杂性: 加入MQ后, 需要考虑的东西增多, 如一致性问题, 保证消息不被重复消费, 保证消息可靠传输等.

## 消息队列实现对比





# 参考

* [一个用消息队列 的人，不知道为啥用 MQ，这就有点尴尬](https://blog.csdn.net/alinshen/article/details/80583214)



















