# Get Start

## 介绍

* 介绍: 静态web服务器
* 用途
  * 反向代理
  * 负载均衡
  * 微服务
  * API网关
  * 邮件代理!
  * HTTP缓存
* TCP, UDP代理
  
* 历史

  * 2004年由[Igor Sysoev](https://en.wikipedia.org/wiki/Igor_Sysoev)创建
  * 2011年,同名公司创建, 提供Nginx Plus付费软件
  * 2019年,该公司被Netcraft收购

  > 尽管Nginx Plus是付费软件, 但Nginx仍是发布在类BSD许可下的开源免费软件.

* 特性

  * 使用异步事件驱动机制, 而非多线程来处理请求, 能够提供更好的负载能力.

    > 不是说异步事件驱动就不会使用多线程处理请求, 仅是从请求到来时, 如何处理请求这个方式来区分的.

  * 可以和其他CGI应用组合, 服务动态网页
  
  * ... 

## 使用

* 组成

  * 一个主进程: 读取和evaluate配置和维护工作进程
  * 多个工作进程: 处理请求的地方

  > 基于事件驱动模型来分发请求, 这个功能谁来干? 不知道...

* 安装(for Ubuntu)

  * 安装前准备必要命令

    ```bash
    sudo apt install curl gnupg2 ca-certificates lsb-release
    ```

  * 设置nginx的apt仓库

    * 使用稳定版本nginx的仓库

        ```bash
        echo "deb http://nginx.org/packages/ubuntu `lsb_release -cs` nginx" | sudo tee /etc/apt/sources.list.d/nginx.list
        ```
        
    * 使用主线版本nginx的仓库

        ```bash
        echo "deb http://nginx.org/packages/mainline/ubuntu `lsb_release -cs` nginx" | sudo tee /etc/apt/sources.list.d/nginx.list
        ```

  * 导入nginx的签名密钥, 校验仓库的可靠性

    ```bash
    curl -fsSL https://nginx.org/keys/nginx_signing.key | sudo apt-key add -
    ```

  * 从nginx仓库中安装软件

    ```bash
    sudo apt update && sudo apt install nginx
    ```

* 管理

  * `nginx`启动

  * `nginx -s stop`快速关闭

  * `nginx -s quit`完整关闭

    > 其他的关闭方法:
    >
    > `kill -s QUIT 1628`, 进程号可从pid文件中获取
    >
    > 使用`QUIT`, 主线程就会去关闭工作线程. 最好不要用`KILL`

  * `nginx -t` 不运行, 仅测试配置文件

  * `nginx -s reload`重载配置

    > 修改配置后需要手动加载.
    >
    > 加载原理: 主线程解析配置, 成功则通知老工作线程做扫尾工作, 并开启新工作进程. 否则仍使用老配置

  * `nginx -s reopen`重开日记文件

    > 作用见 [nginx reload和reopen](https://blog.csdn.net/u010433704/article/details/99817375)

  * `ps aux|grep nginx`查看所有nginx进程

* 文件
  * 日志目录`/usr/local/nginx/logs` 或 `/var/log/nginx`.
  * 配置文件`/etc/nginx/nginx.conf`

# 基础

> 配置位于`/etc/nginx.conf`文件中

## 语法

> nginx配置文件不简单啊, 也有简单的控制逻辑, 这里略.

配置由指令和注解组成, 指令可分为

* 简单指令

  * 由名字和参数组成

  * 多个参数以空格分割

  * 指令以`;`结束

  * 例子

    ```bash
    pid        /var/run/nginx.pid;
    ```

* 块指令

  * 与简单指令结构类似

  * 指令内容被包裹在`{}`之内, 里面可以有其他简单指令或块指令

  * 块指令构成了一个上下文`context`, 用于归类配置

  * 最外层的指令默认处于`main`上下文中

  * 例子

    ```bash
    http {
        include       /etc/nginx/mime.types;
        default_type  application/octet-stream;
    
        log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                          '$status $body_bytes_sent "$http_referer" '
                          '"$http_user_agent" "$http_x_forwarded_for"';
    
        access_log  /var/log/nginx/access.log  main;
    
        sendfile        on;
        #tcp_nopush     on;
    
        keepalive_timeout  65;
    
        #gzip  on;
    
        include /etc/nginx/conf.d/*.conf;
    }
    ```

* 注释: 以`#`开始的行为注释

> 注意, 指令的语义可以含有继承关系

## 文件结构

```
...#全局块

events {events块
   ...
}

http #http块
{
    ...#http全局块
    server#server块
    { 
        ... #server全局块
        location [PATTERN] #location块
        {
            ...
        }
        location [PATTERN] 
        {
            ...
        }
    }
    server
    {
      ...
    }
    ...  #http全局块
}
```

- **全局块**：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。
- **events块**：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。
- **http块**：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。
- **server块**：配置虚拟主机的相关参数，一个http中可以有多个server。
- **location块**：配置请求的路由，以及各种页面的处理情况。

## 默认配置解读

```nginx
##
# You should look at the following URL's in order to grasp a solid understanding
# of Nginx configuration files in order to fully unleash the power of Nginx.
# https://www.nginx.com/resources/wiki/start/
# https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/
# https://wiki.debian.org/Nginx/DirectoryStructure
#
# In most cases, administrators will remove this file from sites-enabled/ and
# leave it as reference inside of sites-available where it will continue to be
# updated by the nginx packaging team.
#
# This file will automatically load configuration files provided by other
# applications, such as Drupal or Wordpress. These applications will be made
# available underneath a path with that package name, such as /drupal8.
#
# Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples.
##

# Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	# SSL configuration
	#
	# listen 443 ssl default_server;
	# listen [::]:443 ssl default_server;
	#
	# Note: You should disable gzip for SSL traffic.
	# See: https://bugs.debian.org/773332
	#
	# Read up on ssl_ciphers to ensure a secure configuration.
	# See: https://bugs.debian.org/765782
	#
	# Self signed certs generated by the ssl-cert package
	# Don't use them in a production server!
	#
	# include snippets/snakeoil.conf;

	root /root/Blog/root/web;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;

	server_name _;

	location / {
		# First attempt to serve request as file, then
		# as directory, then fall back to displaying a 404.
		try_files $uri $uri/ =404;
	}

	# pass PHP scripts to FastCGI server
	#
	#location ~ \.php$ {
	#	include snippets/fastcgi-php.conf;
	#
	#	# With php-fpm (or other unix sockets):
	#	fastcgi_pass unix:/var/run/php/php7.0-fpm.sock;
	#	# With php-cgi (or other tcp sockets):
	#	fastcgi_pass 127.0.0.1:9000;
	#}

	# deny access to .htaccess files, if Apache's document root
	# concurs with nginx's one
	#
	#location ~ /\.ht {
	#	deny all;
	#}
}


# Virtual Host configuration for example.com
#
# You can move that to a different file under sites-available/ and symlink that
# to sites-enabled/ to enable it.
#
#server {
#	listen 80;
#	listen [::]:80;
#
#	server_name example.com;
#
#	root /var/www/example.com;
#	index index.html;
#
#	location / {
#		try_files $uri $uri/ =404;
#	}
#}

```



# Web Server

## 介绍

配置一个Web Server, 就是配置URL如何被处理. 

首先, Http中URL的简化结构如下:

```url
(http|https)://host[:port][path]
```

在Nginx中, 以`host`和`port`确定**Virtual Server**, 以`path`确定`Location`.

`Virtual Server`中含有与Server相关的配置; `Location`确定`path`与访问资源的映射关系, 可以是本地文件或代理服务器(反向代理).

## Virtual Server

* 介绍

  不同的域名或IP的请求被不同的Virtual Server处理

* 结构

    ```nginx
    http {
        server {
            # Server configuration
        }
    }
    ```
    
    > `http`中`server`可有多个
    
* 配置

    * `listen` 设置监听端口和IP

      ```nginx
      server {
          listen 127.0.0.1:8080;
          # The rest of server configuration
      }
      ```

      > IP可省略, 默认所有地址; 端口可省略, nginx有管理员权限时默认`80`端口, 否则`8000`端口

    * `server_name` 设置监听的域名

      ```nginx
      server {
          listen      80;
          server_name example.org www.example.org;
          #...
      }
      ```

      > 可省略, 默认所有域名.

      有三种形式指定域名: 完整域名, 含通配符, 正则. 

      > 其中, 通配符只能位于域名前,后或两端都有
      >
      > ```nginx
      > server {
      >     server_name example.com *.example.com www.example.*;
      > }
      > ```
      >
      > 正则需加前缀`~`
      >
      > ```nginx
      > server {
      >     server_name www.example.com ~^www\d+\.example\.com$;
      > }
      > ```

    * 默认Server

      默认以第一个`server`指令为默认Server. 可通过`listen`的`default_server`参数显式指定, 如:

      ```nginx
      server {
          listen 80 default_server;
          #...
      }
      ```

* 路由规则

    当请求到来时

    1. 找出IP和端口一致的`server`

    2. 再将请求的`Host`与`server_name`比较, 成功匹配则使用该Virtual Server, 否则使用默认Server

## Location

### intro

* 介绍

  映射请求到具体的资源上.

* 语法

  ```nginx
  Syntax:	location [ = | ~ | ~* | ^~ ] uri { ... }
  Default:	—
  Context:	server, location
  ```

### 匹配

* 匹配模式

  有多种匹配方式, 其中后缀匹配可以使用正则.

  * 空: 前缀匹配

    ```nginx
    location /some/path/ {
        #...
    }
    ```

    > 将匹配`/some/path/document.html`

  * `~`: 使用正则进行后缀匹配, 大小写敏感

    ```nginx
    location ~ \.html? {
        #...
    }
    ```

    > 将匹配以`.html`或`.htm`结尾的路径

  * `~*`: 使用正则进行后缀匹配, 大小写不敏感

  * `^~` 前缀匹配, 若匹配成功, 且该前缀最长时, 将不进行后缀匹配过程.

    > 即影响下面的匹配规则

  * `=`: 准确匹配, 同样也无后缀匹配过程

    ```nginx
    location = / {
        #...
    }
    ```

* 匹配规则

  当`server`收到请求时

  1. 先前缀匹配  选择并记住前缀最长的`location`

  2. 再匹配后缀, 选中第一个成功匹配的后缀并**结束**, 使用该`location`的配置

  3. 如果后缀匹配不成功, 则使用之前记住的最长前缀的`location`配置

  > 注意, 前缀匹配过程中,  `=`和`^~`(需满足条件: 前缀最长) 无后缀匹配过程

### 资源映射

#### 静态资源

建立URL路径与文件系统的映射关系

* `root`

  文件的真实路径=系统路径+URL路径.

    ```nginx
  server {
      location /images/ {
          root /data;
      }
}
    ```
  
    > 如请求路径`/images/example.png`, 访问的文件路径则为`/data/images/example.png`
  
* `alias`

  文件的真实路径=系统路径+去掉匹配前缀的URL路径

  ```nginx
  server {
      location /images/ {
          root /data;
      }
  }
  ```

  > 如请求路径`/images/example.png`, 访问的文件路径则为`/data/example.png`

#### 反向代理

* `proxy_pass`

  `proxy_pass`确定URL路径和**代理Server**的关系, 文件的真实路径=代理URL+去掉匹配前缀的URL路径

  ```nginx
  server{
   	location /app/ {
      	proxy_pass      http://192.168.154.102;
  	}   
  }
  ```

  > `test.com/app/xxxxx` =>  `http://192.168.154.102/xxxxx`

  ```nginx
  server{
   	location /app/ {
          proxy_pass      http://192.168.154.102/maped_dir/;
      }   
  }
  ```

  > `test.com/app/xxxxx` =>  `http://192.168.154.102/maped_dir/xxxxx`

  > 详细参考[Nginx proxy_pass: examples for how does nginx proxy_pass map the request](https://www.liaohuqiu.net/posts/nginx-proxy-pass/)

## 其他

### 重写URL

```nginx
location /users/ {
    rewrite ^/users/(.*)$ /show?user=$1 break;
}
```

`rewrite`指令有三个参数, 第一个是匹配当前`location`环境中URL路径的一个正则, 第二个是重写后的URL路径, 第三个是后续行为, 常用值有:

* `last` 使用重写后的URL, 重新寻找合适的`location`, 让其处理
* `break` 使用重写后的URL, 继续在当前`location`中执行

例子

```nginx
server {
    #...
    rewrite ^(/download/.*)/media/(.*)\..*$ $1/mp3/$2.mp3 last;
    rewrite ^(/download/.*)/audio/(.*)\..*$ $1/mp3/$2.ra  last;
    return  403;
    #...
}
```

> 若匹配正则, 则重写, 否则返回403

> 参考
>
> * [Module ngx_http_rewrite_module](https://nginx.org/en/docs/http/ngx_http_rewrite_module.html?&_ga=2.127166349.1048841569.1579135406-2037701528.1578467350)
> * [Rewriting URIs in Requests](https://docs.nginx.com/nginx/admin-guide/web-server/web-server/#rewriting-uris-in-requests)

### 请求头部

* 介绍

  代理过程中, 默认请求头部也被转发, 即`proxy_pass_request_headers `和`proxy_pass_request_body`默认为`on`.

  但有例外, 如`Host`, `Connection`被重置为

  ```nginx
  proxy_set_header Host       $proxy_host;
  proxy_set_header Connection close;
  ```

  并且自定义头部不被转发.

* `proxy_set_header`

  该指令可修改或新增头部字段. 

  如, 代理默认不转发`host`头部, 现在让Niginx转发

    ```nginx
  proxy_set_header Host  $http_host;
    ```
  
  > 这种方式有弊端, 若请求未存在`host`字段, 也不会被转发.
  >
  > `$XXX`变量详细请见 [其他/变量]
  
* Demo

  代理时经常重写的头字段

  ```nginx
  proxy_set_header   Host                 $host:$server_port;
  proxy_set_header   X-Real-IP            $remote_addr;
  proxy_set_header   X-Forwarded-For      $proxy_add_x_forwarded_for;
  proxy_set_header   X-Forwarded-Proto    $scheme;
  ```


> 参考
>
> * [proxy_set_header](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header)
> * [proxy_pass_request_headers](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_headers)
> * [proxy_pass_request_body](http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass_request_body)

### 修改响应

# 进阶

## HTTPS

直接看例子

```nginx
# https配置与反向代理
server {
    # 监听的端口,ip,域名
    listen 443 default_server ssl;
    listen [::]:443 default_server ssl;
    server_name sidian.live www.sidian.live;
    # SSL 配置
    ssl_certificate /etc/nginx/cert/sidian.live.pem;   # 证书。
    ssl_certificate_key /etc/nginx/cert/sidian.live.key;   # 密钥
    ssl_session_timeout 5m;
    ssl_ciphers HIGH:!aNULL:!MD5;  # 加密算法
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;   # 加密协议
    ssl_prefer_server_ciphers on; # 首选使用服务端的算法
    # 前端网页
    location / {
        try_files $uri $uri/ =404;
        root /root/Blog/root/web; # 前端页面位置
        index index.html index.htm;
    }
    # 后端API代理
    location /api/ {
        rewrite ^/api/(.*)$ /$1 break; # 去掉API前缀
        proxy_pass http://localhost:8080; # 代理地址
    }
}

# http重定向到https
server {
        listen 80;
        server_name sidian.live www.sidian.live;
        return 301 https://$server_name$request_uri;
}
```

若报错`SSL_ERROR_RX_RECORD_TOO_LONG`, 则`listen`上添加`ssl`, 表示开启ssl

```nginx
listen 443 ssl;
```

> 参考
>
> * [在Nginx/Tengine服务器上安装证书](https://help.aliyun.com/document_detail/98728.html?spm=5176.2020520154.0.0.675456a7crLH9u)
> * [Nginx安装SSL配置HTTPs超详细完整全过程](https://www.hack520.com/481.html)
>
> HTTPS进一步优化
>
> * [八个HTTPS和SSL优化使用心得-减少等待时间和降低Https性能损耗](https://wzfou.com/https-ssl/)
> * [SSL Configuration Generator](https://ssl-config.mozilla.org/)
> * [linux安装nginx、增强配置ssl、http2](https://blog.csdn.net/long2010110/article/details/82351206)

## upstream

* 介绍

  `upstream`定义了一组Servers, 用于负载均衡, 在`proxy_pass`, `fastcgi_pass`等代理指令中使用.

  使用加权轮询的方式将请求分散在各个请求中; 如果请求在一个Server中响应失败, 将传给下一个Server, 直到最后一个Server也失败, 最终返回最后一个Server的响应.

* 例子

  ```nginx
  upstream backend {
      //使用默认权重
      server backend1.example.com       weight=5;
      //指定端口
      server backend2.example.com:8080;
      //可以是ip地址, 并指定失败条件
      server 127.0.0.1:8080       max_fails=3 fail_timeout=30s;
      //可混合unix socket
      server unix:/tmp/backend3;
  	//备用server
      server backup1.example.com:8080   backup;
      server backup2.example.com:8080   backup;
  }
  
  server {
      location / {
          //在代理相关的指令中使用
          proxy_pass http://backend;
      }
  }
  ```

  > 我自己有个疑问, `backup`有存在的必要吗?

> 参考
>
> * [Module ngx_http_upstream_module](http://nginx.org/en/docs/http/ngx_http_upstream_module.html)
> * [What does upstream mean in nginx?](https://stackoverflow.com/questions/5877929/what-does-upstream-mean-in-nginx)

## stream

TCP, UDP代理配置在`stream`指令中. `stream`指令与`http`指令同级

一个Demo

```nginx
stream {
    upstream backend {
        hash $remote_addr consistent;

        server backend1.example.com:12345 weight=5;
        server 127.0.0.1:12345            max_fails=3 fail_timeout=30s;
        server unix:/tmp/backend3;
    }

    upstream dns {
       server 192.168.0.1:53535;
       server dns.example.com:53;
    }

    # 代理tcp
    server {
        listen 12345;
        proxy_connect_timeout 1s;
        proxy_timeout 3s;
        proxy_pass backend;
    }
	
    # 代理udp, 需要有udp和reuseport参数
    server {
        listen 127.0.0.1:53 udp reuseport;
        proxy_timeout 20s;
        proxy_pass dns;
    }
    # 代理linux socket
    server {
        listen [::1]:12345;
        proxy_pass unix:/tmp/stream.socket;
    }
}
```

> 好像必须要有`upstream`哦

> 参考[http://nginx.org/en/docs/stream/ngx_stream_core_module.html]

## gzip压缩

* `gzip`

  是否开启压缩功能, 默认`off`

* `gzip_buffers`

  压缩时使用到的缓存大小, 默认`4k`或`8k`

* `gzip_comp_level`

  压缩等级, 默认1 (最低)

* `gzip_disable`

  设置配置模式, `User-Agent`上匹配到的请求不压缩.

* `gzip_min_length`

  要压缩的响应必须满足的大小下限, 默认20Byte

* `gzip_proxied`

  是否启动反向代理的压缩. 默认`off`, 不压缩

* `gzip_types`

  什么样的响应需要压缩, `text/html`总是会被压缩, 无需特别指定.

* `gzip_vary`

  压缩的响应中是否添加头字段`Vary: Accept-Encoding`

例子

```nginx
gzip            on; # 开启压缩
gzip_min_length 1k; # 1k以上的才压缩
gzip_proxied    expired no-cache no-store private auth; # 部分代理请求要压缩,主要压缩后端允许缓存的内容
gzip_types text/plain application/javascript text/css application/xml text/javascript; # 仅压缩网页,图片压缩慢,且压缩率低, 就不压缩了
gzip_comp_level 2; # 提高压缩率
gzip_vary on;
```

## 超时时间

nginx默认有超时时间, 可修改

    proxy_read_timeout 600;
    proxy_connect_timeout 600;
    proxy_ignore_client_abort on;
> 参考[Module ngx_http_proxy_module](http://nginx.org/en/docs/http/ngx_http_proxy_module.html)

## 访问日志

```nginx
server{
    ...
        
    access_log /data/log/nginx/logs/gitlab.access.log;
}
```

## 代理服务的常用配置

```nginx
location / {
    proxy_pass http://192.168.0.177:7000/;
    proxy_redirect http://112.34.250.45/ http://$host:$server_port/ ;
	proxy_set_header   Host $host:$server_port; 
    proxy_set_header   X-Real-IP   $remote_addr;
    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;
}
```

其中, 

* `proxy_redirect `修改响应的重定向地址, 保证正确的指向nginx

* `X-Forwarded-For` 是一个 HTTP 扩展头部，用来表示 HTTP 请求端真实 IP , 格式:

  ```
  X-Forwarded-For: client, proxy1, proxy2
  ```

## Vue HTML5 Model

```nginx
location / {
  try_files $uri $uri/ /index.html;
}
```

# 其他

## 变量

nginx中可以定义变量, 也提供了代表请求头字段的变量.

常用变量如下:

* `$http_<name>`

  代表任意请求头部字段, `<name>`为转化后的字段名, 即小写, 且`-`替换为`_`. 如`HOST` --> `$http_host`

* `$host`

  代表URL上的host. 与`$http_host`相比, 无port

  > `$http_host` vs. `$host` , 见[What's the difference of $host and $http_host in Nginx](https://stackoverflow.com/questions/15414810/whats-the-difference-of-host-and-http-host-in-nginx)
  
* 端口

  * `$proxy_port` 被代理服务器的端口, 即`proxy_pass`上指定的端口
  * `$server_port` server监听的端口

> 见[Embedded Variables](https://nginx.org/en/docs/http/ngx_http_core_module.html?&_ga=2.36392416.114713352.1578467350-2037701528.1578467350#variables)

## 踩坑

### 403 forbidden

403说明我们的访问受限, 很多种原因都可造成403, 这里只谈及我遇到的.

原因:

虽然我们是通过`root`用户运行的Nginx, 但是在它的配置文件中, 指定了工作进程使用`nginx`用户来运行. 因此不能访问`root`用户的文件.

解决方案:

1. 在配置文件中指定工作进程以`root`身份运行, 但不安全
2. 改变文件所属者为`nginx`, 给与目录访问权限即可. (推荐)

> 参考:[Nginx出现403 forbidden](https://blog.csdn.net/qq_35843543/article/details/81561240)

## 常用配置(弃)

location或server中常用配置

```nginx
proxy_http_version 1.1;
#静态站点访问策略一般一个页面会有多个jpg,css,js等,开启会话保持
proxy_set_header Connection "Keep-Alive"; 
#nginx参数，使用客户端的Host
proxy_set_header Host $host:$server_port; 
#L7负载常用配置，由于waf反向代理，X-Real-IP需要在F5进行开启
proxy_set_header X-Real-IP $remote_addr;
#X-Forwarded-For 是一个 HTTP 扩展头部，用来表示 HTTP 请求端真实 IP
#格式X-Forwarded-For: client, proxy1, proxy2
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
```



# 参考

* [所有指令](http://nginx.org/en/docs/http/ngx_http_core_module.html)
* [Web Server](https://docs.nginx.com/nginx/admin-guide/web-server/web-server/) Nginx Plus的文档, 讲的比较细











